---
rip: 7728
title: L1SLOAD 프리컴파일
description: L1 스토리지 슬롯을 로드하는 프리컴파일 컨트랙트 추가 제안
author: Haichen Shen (@icemelon), Péter Garamvölgyi (@Thegaram)
discussions-to: https://ethereum-magicians.org/t/rip-7728-l1sload-precompile/20388
status: Draft
type: Standards Track
category: Core
created: 2024-06-24
---

## 개요

이 제안은 컨트랙트 주소와 스토리지 키가 주어지면 L1에서 여러 스토리지 슬롯을 로드하는 새로운 프리컴파일 컨트랙트 `L1SLOAD`를 도입합니다.

## 동기

이더리움의 수많은 L2로 인해 멀티체인 스마트 컨트랙트를 구축하는 것이 어려워졌습니다. 이 제안은 L2 체인에 배포된 스마트 컨트랙트가 L1에서 스토리지 값을 읽을 수 있는 편리하고 신뢰할 수 있는 방법을 제공합니다. 이는 개발자가 직접 MPT 증명을 생성하고 제출할 필요를 없애 개발자 경험을 개선합니다.

사용 사례의 예는 스마트 계정(멀티시그 및 AA 지갑)의 키 관리입니다. L1에 이미 지갑이 있을 때 사용자는 더 이상 L2에서 구성 및 서명 키를 설정할 필요 없이 L1에서 직접 로드할 수 있습니다. L1 상태에 직접 접근함으로써 이점을 얻을 수 있는 다른 많은 사용 사례가 있다고 믿습니다.

커뮤니티에서 이전에 유사한 제안이 있었습니다. Brecht Devos는 L2의 컨트랙트가 L1에 배포된 컨트랙트를 호출할 수 있게 하는 [`L1CALL`](https://ethresear.ch/t/cross-layer-communication-trivially-provable-and-efficient-read-access-to-the-parent-chain/15396)을 제안했습니다. Optimism도 [원격 정적 호출](https://github.com/ethereum-optimism/ecosystem-contributions/issues/76)에 대한 유사한 RFP를 가지고 있었습니다. 제안된 정적 호출 메커니즘은 단순한 상태 읽기보다 더 강력하지만, L1 EVM 실행이 L2의 일부가 되도록 강제하여 L2 체인의 채택을 방해합니다. `L1SLOAD`는 더 기본적인 기능을 제공하고 L2에 더 많은 유연성을 허용합니다. (a) L2가 EVM을 수정하기가 더 쉽고 (2) 이 프리컴파일은 완전히 비EVM 호환 L2에서도 구현될 수 있기 때문입니다.


## 사양

### 상수

| 이름                  | 값               |
|:---------------------:|:----------------:|
| PRECOMPILED_ADDRESS   | TBD              |
| FIXED_GAS_COST        | 2000 (잠정)      |
| PER_LOAD_GAS_COST     | 2000             |
| MAX_NUM_STORAGE_SLOTS | 5 (잠정)         |

### 프리컴파일

`L1SLOAD` 프리컴파일의 입력은 L1 컨트랙트 주소와 `MAX_NUM_STORAGE_SLOTS`까지의 $k$개 스토리지 키입니다.

| 바이트 범위 | 이름 | 설명 |
| --- | --- | --- |
| [0: 19] (20 bytes) | `address` | 컨트랙트 주소 |
| [20: 51] (32 bytes) | `key1` | 스토리지 키 |
| ... | ... | ... |
| [`k`\*32-12: `k`\*32+19] (32 bytes) | `keyk` | 스토리지 키 |

출력은 L2 시퀀서에게 알려진 최신 L1 블록 번호에서의 L1 스토리지 값입니다.

| 바이트 범위 | 이름 | 설명 |
| --- | --- | --- |
| [0: 31] (32 bytes) | `value1` | L1 스토리지 값 |
| ... | ... | ... |
| [(`k`-1)\*32: `k`\*32] (32 bytes) | `valuek` | L1 스토리지 값 |

### 구현

**전제조건 1**: L2 시퀀서는 L1 노드에 접근할 수 있어야 합니다. 시퀀서가 L1에서 입금 트랜잭션을 모니터링해야 하므로 이미 L1 노드를 내부에 내장하거나(선호) L1 RPC 엔드포인트에 접근할 수 있습니다.

`L1SLOAD` 프리컴파일 도입은 L2 노드가 이전 블록에서 L2 체인을 동기화할 때 L1 노드 또는 L1 RPC 엔드포인트가 아카이브 노드여야 하는 요구사항을 증가시킬 수 있습니다.

**전제조건 2**: L2 시퀀서는 모든 L2 노드에서 결정론적인 *최신 본 L1 블록* 개념을 가지고 있으며, 즉 L2 상태 머신의 일부입니다. 정확한 메커니즘은 이 RIP의 범위 밖입니다.

**구현**: L2 노드가 `L1SLOAD` 프리컴파일 컨트랙트 호출을 만나면 먼저 입력이 올바른 형식인지 확인합니다. 그런 다음 최신 본 L1 블록 번호 `l1BlockNumber`를 검색하고 L1 노드에 `eth_getStorageAt(address, storageKey, l1BlockNumber)` RPC 쿼리를 보냅니다. 마지막으로 수신된 스토리지 값을 지정된 출력 버퍼에 씁니다.

### 오류

`L1SLOAD` 프리컴파일이 처리해야 하는 몇 가지 오류 케이스가 있습니다:
- **유효하지 않은 입력**: 입력이 유효하지 않으면 제공된 가스가 소비되고 반환 데이터가 없습니다. 이는 프리컴파일에 제공된 바이트 수가 올바르지 않은 경우일 수 있습니다.
- **유효하지 않은 출력 버퍼**: 출력 버퍼가 반환 데이터를 담기에 충분히 크지 않을 때.
- **불충분한 가스**: 충분한 가스가 제공되지 않으면 반환 데이터가 없습니다.
- **RPC 오류**: L2 시퀀서가 L1 노드에서 RPC 오류를 받으면 L2 시퀀서는 RPC 요청을 재시도하거나 트랜잭션을 txpool에 다시 삽입해야 합니다. 이 경우는 되돌림으로 이어져서는 안 됩니다. 다른 노드가 트랜잭션을 재생할 때 불일치가 발생할 수 있기 때문입니다. 따라서 이는 실행 오류가 아닌 내부 오류로 처리되어야 합니다.

### 가스 비용

`L1SLOAD`의 가스 비용은 `FIXED_GAS_COST + k * PER_LOAD_GAS_COST`이며, 여기서 `k`는 스토리지 슬롯 수입니다. 상수는 더 많은 벤치마크 후에 변경될 수 있습니다.

`FIXED_GAS_COST`는 L1 클라이언트에 대한 추가 RPC 호출 지연을 고려합니다. 모든 스토리지 키는 `L1SLOAD`에서 콜드 키로 처리되므로 로드할 각 스토리지 슬롯에 2000 가스를 사용합니다.

### 예시

다음은 `L1SLOAD` 프리컴파일을 사용하는 예시 Solidity 코드 스니펫입니다.

```solidity
function loadFromL1(address l1Address, uint256 key1, uint256 key2) public view returns (uint256, uint256) {
    address L1_SLOAD_ADDRESS = 0x101;
    (bool success, bytes memory ret) = L1_SLOAD_ADDRESS.staticcall(
        abi.encodePacked(l1Address, key1, key2)
    );
    if (!success) {
        revert("L1SLOAD failed");
    }
    return abi.decode(ret, (uint256, uint256));
}
```

## 근거

### `L1SLOAD`는 어떤 L1 블록에서 스토리지 값을 읽나요?

위에서 정의된 사양에 따르면 `L1SLOAD`는 L2 시퀀서에게 알려진 최신 L1 블록에서 스토리지 값을 반환합니다. 관련된 두 가지 문제가 있습니다:
- `L1SLOAD`의 일관된 반환 값을 보장하는 방법
- 매우 오래된 L1 상태에서 스토리지 값을 로드하는 위험.

첫째, 트랜잭션 재생 중에 반환 값이 일관되도록 하려면 L2 체인은 L2 시퀀서에게 알려진 최신 L1 블록 정보를 저장하는 시스템 컨트랙트를 제공해야 합니다. Optimism은 이미 사전 배포된 컨트랙트 [`L1Block`](https://docs.optimism.io/stack/protocol/rollup/smart-contracts#l1block)을 제공합니다. Scroll은 L1 블록 정보를 신뢰 없이 가져오고 상태 루트, 타임스탬프, RANDAO 등 다른 헤더 필드도 저장하는 새로운 시스템 컨트랙트 [설계](https://www.notion.so/scrollzkp/L1Blocks-System-Contract-b1a137eacea74819a3fa57d7d6e52498?pvs=4)를 가지고 있습니다.

둘째, L2 프로토콜은 자체 재량에 따라 L1 블록 가져오기 지연을 결정합니다. `L1SLOAD`를 더 유용하게 만들고 오래된 L1 스토리지 상태 읽기의 위험을 줄이려면 가져오기 지연이 너무 길지 않아야 합니다(예: 보통 약 18-19분이 걸리는 최종 상태를 기다리는 것). 이더리움 체인 재조직 위험이 낮으면서 가져오기 지연이 상당히 짧은(약 2분) 약 10 L1 블록 확인을 기다리는 것을 제안합니다. 이를 채택하려면 L2 시퀀서가 긴 L1 체인 재조직이 있을 때 상황을 처리할 수 있어야 합니다. 또한 애플리케이션이 오래된 스토리지 읽기에 민감한 경우 개발자는 시스템 컨트랙트에서 검색한 L1 블록 번호와 최신 L1 블록 번호 간의 차이를 애플리케이션 요구사항에 따라 제한할 수 있습니다.

### 추가 RPC 지연으로 인한 L2 시퀀서 오버헤드
`L1SLOAD` 프리컴파일은 추가 RPC 지연 및 간헐적 RPC 오류의 위험을 도입합니다. 두 위험 모두 L2 시퀀서와 동일한 클러스터에서 L1 노드를 실행하여 완화할 수 있습니다. L2 운영자가 더 나은 보안과 신뢰성을 얻기 위해 타사를 사용하는 대신 자체 L1 노드를 실행하는 것이 바람직합니다. 이러한 설정에서 지연 오버헤드를 정량화하기 위해 더 많은 벤치마크를 수행할 것입니다.

## 증명 메커니즘

`L1SLOAD` 프리컴파일은 머클 포함 증명을 검증하지 않고 스토리지 값을 직접 반환하므로 정확성 증명 책임은 L2 프로토콜에 있습니다. 여기서 `L1SLOAD`를 증명하는 방법을 간략히 설명합니다:
- 첫째, 마지막으로 알려진 L1 블록의 상태 루트를 검증해야 합니다. L1 블록 시스템 컨트랙트가 블록해시나 상태 루트와 같은 L1 블록 헤더의 일부 정보를 저장한다고 가정합니다. 상태 루트가 시스템 컨트랙트에 저장되어 있으면 L1 상태 루트를 시스템 컨트랙트에서 직접 읽을 수 있으며 상태 루트의 검증은 L1 블록 시스템 컨트랙트의 설계에 맡겨집니다. 블록해시만 컨트랙트에 저장된 경우 블록 헤더를 제공하여 블록해시에서 상태 루트를 디코딩할 수 있습니다.
- 둘째, 스토리지 값의 정확성을 증명해야 합니다. ZK 롤업은 스토리지 머클 포함 증명을 증인 데이터로 사용하고 회로에서 L1 상태 루트로의 머클 경로를 검증할 수 있습니다. 마찬가지로 옵티미스틱 롤업은 사기 증명의 일부로 머클 포함 증명을 증명할 수 있습니다.

## 하위 호환성

프리컴파일 컨트랙트가 프리컴파일 주소 집합의 다음 사용 가능한 주소인 `PRECOMPILED_ADDRESS`에 추가되므로 하위 호환성 문제는 없습니다.
