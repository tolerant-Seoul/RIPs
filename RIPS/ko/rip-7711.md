---
rip: 7711
title: 네이티브 계정 추상화에서 검증-실행 분리
description: 효율적인 블록 빌딩을 가능하게 하는 RIP-7560 트랜잭션의 블록 내 프레임 실행 순서 변경
author: Vitalik Buterin (@vbuterin), Yoav Weiss (@yoavw), Alex Forshtat (@forshtat), Dror Tirosh (@drortirosh), Shahaf Nacson (@shahafn)
discussions-to: https://ethereum-magicians.org/t/rip-7711-an-rip-7560-compatible-transactions-bundle-transaction-type/20093
status: Draft
type: Standards Track
category: Core
created: 2023-09-01
requires: 7560
---


## 개요

이 제안은 블록 빌더에게 RIP-7560 트랜잭션 집합에 대해 검증을 실행에서 분리하는 메커니즘을 제공합니다.
이를 통해 RIP-7560 트랜잭션으로 블록 가스 공간을 채우는 작업을 단순화하고 블록 빌더에 대한 잠재적 서비스 거부 공격을 방지합니다.

전통적인 의미의 "트랜잭션 멤풀"이 없는 "단일 시퀀서" 레이어 2 체인에서는 원래 RIP-7560에 비해 이 제안이 이점을 제공하지 않습니다.
그러나 블록 빌딩을 위해 공개 멤풀에 의존하는 모든 체인에서 DoS 완화를 위해 필요합니다.

## 동기

RIP-7560에서 정의된 `AA_TX_TYPE` 트랜잭션 타입은 ECDSA 서명이나 다른 프로토콜 정의 규칙에서 트랜잭션 유효성을 프로토콜 수준에서 완전히 분리하고, 대신 계정의 EVM 코드가 트랜잭션의 유효성을 결정하도록 합니다.

그러나 이 검증 EVM 코드는 블록 내의 관찰 가능한 상태 변경에 영향을 받을 수 있습니다.
`AA_TX_TYPE` 트랜잭션 집합을 포함하려는 블록 빌더는 서로를 무효화하지 않고 함께 맞는 조합을 찾는 어려움에 직면할 수 있습니다.

블록 빌더는 다음 트랜잭션을 선택하기 전에 하나의 트랜잭션 전체 본문을 실행해야 합니다.
또한 트랜잭션 실행에 제한을 적용하는 것이 실현 불가능한 반면, 검증 코드는 ERC-7562와 같은 규칙 집합으로 블록 빌더에 의해 제한될 것으로 예상됩니다.

이 문서는 블록 빌더가 `AA_TX_TYPE` 트랜잭션 집합을 지정하는 메커니즘을 제안하며, 모든 검증 프레임이 해당 실행 프레임 전에 연속적으로 먼저 실행된다는 사실로 인해 함께 맞는 것이 보장됩니다.

## 사양

### 비원자적 검증 및 실행 트랜잭션 타입

```
BUNDLE_TRANSACTION_TYPE = x
```

이 트랜잭션은 "AA 트랜잭션 번들"로 구성되는 것을 제외하고 일반 RIP-7560 트랜잭션과 완전히 동일합니다.

일부 스마트 컨트랙트 계정이 검증과 실행 단계 간의 원자성에 의존하는 방식으로 생성될 수 있으므로, 지갑이 `BUNDLE_TRANSACTION_TYPE`을 수락하여 이 기능에 명시적으로 옵트인하는 것이 중요합니다.

### AA 트랜잭션 번들

AA 트랜잭션 번들에서 모든 검증 상태 변경은 모든 실행 전에 적용됩니다.

AA 트랜잭션으로 블록을 채우는 것이 블록 빌더에게 어려움이 되어서는 안 됩니다.
그러나 각 트랜잭션이 실행 중에 멤풀의 다른 트랜잭션 유효성에 영향을 미치는 상태를 변경할 수 있다면, 블록 빌더는 각 포함 후 멤풀의 모든 트랜잭션을 재검증해야 합니다.
`BUNDLE_TRANSACTION_TYPE` 타입의 트랜잭션은 `AA_TX_TYPE` 트랜잭션을 포함하는 블록을 빌드하는 고유한 계산 복잡성을 완화합니다.

`BUNDLE_TRANSACTION_TYPE` 트랜잭션에서는 중단되지 않은 AA 트랜잭션 시퀀스의 **모든** 검증 프레임이 먼저 실행되고, **모든** 실행 프레임이 그 직후에 실행됩니다.

### 검증 코드 샌드박싱

RIP-7711에서도 `BUNDLE_TRANSACTION_TYPE` 트랜잭션 번들의 검증 프레임은 동일한 번들의 다른 트랜잭션을 무효화할 수 있습니다.
[ERC-7562](../eip-7562)에서 완전히 설명된 멤풀 트랜잭션에 대한 특정 규칙을 적용하여 교차 검증 종속성을 방지하는 메커니즘을 정의합니다.
이는 ERC-4337 UserOperations 멤풀에서 사용하는 메커니즘과 동일합니다.

ERC-7562의 규칙을 시행하지 않기로 선택한 빌더는 블록에 포함되는 위치에서 중간 블록 상태에 대해 각 트랜잭션을 재검증하도록 **주의해야 합니다**.
그렇지 않으면 결과 블록이 무효가 될 가능성이 높습니다.

### 블록 구조 다이어그램

다음은 여러 계정 추상화 트랜잭션을 포함하는 블록의 시각적 표현입니다.
AA 트랜잭션의 검증 부분은 별도의 트랜잭션으로 실행되지만, 블록 데이터에서 별도의 트랜잭션으로 표현되지 않습니다.

![](../assets/rip-7711/rip_7711_block_overview.png)
*여러 RIP-7711 네이티브 계정 추상화 트랜잭션을 포함하는 블록 구조*

비교를 위해, RIP-7560 트랜잭션을 사용하는 유사한 블록의 다이어그램입니다:

![](../assets/rip-7711/rip_7560_block_overview.png)
*여러 RIP-7560 트랜잭션을 포함하는 블록 구조*

### 트랜잭션 실행 컨텍스트

RIP-7711 이전에 EVM의 일부 동작은 트랜잭션 컨텍스트에 의존하는 것으로 정의되었습니다.
이러한 동작은:
1. [EIP-2200](../eip-2200)에 따른 `SSTORE` 옵코드 비용
2. [EIP-2929](../eip-2929)에 따른 콜드 주소 및 슬롯 접근 비용
3. [EIP-1163](../eip-1163)에 따른 임시 스토리지 내에서 사용 가능한 값

RIP-7711 트랜잭션의 모든 검증 및 실행 프레임은 이러한 EIP의 목적상 개별 트랜잭션으로 동작합니다.

즉, 예를 들어 한 프레임에서 TSTORE로 설정한 값은 다음 프레임에서 사용 가능하지 않으며, 서로 다른 트랜잭션은 TSTORE 슬롯에 독립적인 값을 보유합니다.

[EIP-3529](../eip-3529)에 따라 실행 후 할당되는 최대 가스 환불량은 전체 RIP-7711 트랜잭션 가스 비용에 적용되며 단계별로 분할되지 않습니다.

### `SELFDESTRUCT` 옵코드의 동작
[트랜잭션 실행 컨텍스트](#트랜잭션-실행-컨텍스트) 섹션에 정의된 규칙의 유일한 예외는 [EIP-6780](../eip-6780)에서 정의한 `SELFDESTRUCT` 옵코드의 가용성입니다.
`SELFDESTRUCT` 사용은 컨트랙트가 생성된 동일한 **프레임** 내에서만 허용됩니다.

### 미사용 가스 패널티 청구

```
UNUSED_GAS_PENALTY = 10
```

미사용 `callGasLimit` 및 `paymasterPostOpGasLimit`의 `UNUSED_GAS_PENALTY` 퍼센트 패널티가 트랜잭션 `sender` 또는 `paymaster`에게 청구됩니다.

이 패널티는 실행 프레임과 `postPaymasterTransaction`에 별도로 적용됩니다.
미사용 가스는 해당 프레임에 대해 다음과 같이 계산됩니다:

```
uint256 unusedGasExecution = executionGasLimit - gasUsedByExecution;
uint256 unusedExecutionGasPenalty = unusedGasExecution * UNUSED_GAS_PENALTY / 10;
```

`unusedExecutionGasPenalty`는 실행 프레임이 완료된 직후 `postPaymasterTransaction` 프레임에 전달되기 전에 `actualGasUsed`에 추가됩니다.

```
uint256 unusedGasPostOp = paymasterPostOpGasLimit - gasUsedByPostOp;
uint256 unusedPostOpGasPenalty = unusedGasPostOp * UNUSED_GAS_PENALTY / 10;
```

`unusedPostOpGasPenalty`는 `postPaymasterTransaction` 후에 `actualGasUsed`에 추가됩니다.

## 근거

### 미사용 가스 패널티 청구

`validationGasLimit`, `paymasterGasLimit` 및 `callGasLimit` 필드를 사용하여 많은 가스를 예약하지만 예약된 가스를 사용하지 않는 `BUNDLE_TRANSACTION_TYPE` 타입의 트랜잭션은 블록 빌더에게 문제를 제시합니다. 이는 특히 트랜잭션이 사용하는 가스가 블록 내 위치에 따라 크게 다를 수 있는 경우에 요구되며, 이러한 트랜잭션은 블록 빌더가 완전히 활용된 블록이 발견될 때까지 알고리즘을 여러 번 반복하게 할 수 있습니다.

무제한 가스 한도 지정을 허용하는 효과는 다음 다이어그램에 표시됩니다:
![](../assets/rip-7560/unused_gas_attack_overview.png)

### 트랜잭션 흐름을 비원자적 조각으로 분할

트랜잭션 흐름을 변경하는 것은 이더리움 트랜잭션의 표준에서 벗어나지만, 실제로 이 변경은 매우 유용하고 그다지 복잡하지 않습니다.

검증 프레임은 가스 한도와 옵코드 금지로 쉽게 제한될 수 있습니다.
따라서 올바르게 빌드된 번들의 전체 검증 섹션은 상호 배타적인 트랜잭션을 포함하지 않도록 보호될 수 있습니다.
블록 빌딩 작업은 효율적이 되며 DoS 공격 위험 없이 병렬화될 수 있습니다.

EVM 구현에서 검증 프레임은 독립 실행형 트랜잭션과 거의 동일하게 동작하므로 이 제안을 구현하는 데 예상되는 어려움이 없습니다.

## 하위 호환성

RIP-7711 트랜잭션의 비원자적 흐름은 스마트 컨트랙트 계정 개발자가 검증과 실행 프레임 사이에 계정이 손상된 상태로 남지 않도록 주의해야 합니다.

그러나 ERC-4337은 UserOperations에 대해 매우 유사한 실행 흐름을 가지므로 계정 추상화의 알려진 속성이며 모든 기존 코드는 약간의 수정만으로 RIP-7711과 호환될 가능성이 높습니다.

## 보안 고려사항

### 검증-실행 분리에 대한 공격

RIP-7560의 계정은 검증과 실행이 원자적일 것을 기대하지 않도록 지시됩니다.
그러나 지갑은 검증과 실행 단계 사이에 아무것도 발생할 수 없다는 잘못된 가정으로 구현될 수 있으며, 이는 틀립니다.

검증 프레임 끝에 존재하는 상태는 실행 프레임이 시작되기 전에 관련 없는 컨트랙트에 의해 관찰되거나 수정될 수 있습니다.
스마트 컨트랙트 계정 개발자 컨트랙트는 코드가 잘못된 가정을 하지 않도록 해야 합니다.

## 저작권

저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기되었습니다.
