---
rip: 7614
title: 컨트랙트에 콜 스택 노출
description: 옵코드, 주소 및 함수 선택자를 기록하는 콜 스택을 구현하고 프리컴파일 컨트랙트를 통해 노출합니다.
author: Caner Çıdam (@canercidam) <caner@openzeppelin.com>, Jonathan Alexander (@jalex206) <jonathan@openzeppelin.com>, Andrew Beal (@ajbealETH) <andy@forta.org>, Ariel Tempelhof (@ArielTM) <ariel.t@spherex.xyz>, Oren Fine (@orenfine) <orenfine@spherex.xyz>, Assaf Eli (@assafIronblocks) <assaf@ironblocks.com>, Or Dadosh (@ordd) <or@ironblocks.com>, Idan Levin <idan@collider.vc>, Alejandro Navarro (Grover-a5) <anavarro@neurablock.ai>
discussions-to: https://ethereum-magicians.org/t/rip-expose-call-stack-to-contracts/18535
status: Draft
type: Standards Track
category: Core
created: 2024-07-02
---

## 개요

옵코드, 주소 및 함수 선택자를 기록하는 콜 스택을 구현하고 프리컴파일 컨트랙트를 통해 노출합니다. 구현되면 프리컴파일은 프로토콜에게 실행의 어느 지점에서든 관련된 주소에 대한 더 깊은 가시성을 제공합니다.

## 동기

이 제안은 트랜잭션 콜 스택에 대한 더 깊은 가시성에 의존하는 더 강력한 익스플로잇 방지 솔루션을 가능하게 함으로써 이더리움 L2 생태계에서 스마트 컨트랙트 보안을 발전시키고자 합니다.

지난 1년간 위협 탐지가 많이 발전했습니다. 모니터링 및 익스플로잇 탐지에 집중하는 보안 프로젝트가 최소 12개 이상 있으며, 이들은 공격자를 사전에 식별할 수 있음을 집단적으로 입증하고 있습니다. 조기 탐지는 정적 및 동적 분석의 조합을 사용하여 악성 스마트 컨트랙트가 온체인에 배포되자마자 식별할 수 있는 능력에 달려 있습니다. 악성 컨트랙트가 플래그되면 프로토콜은 들어오는 트랜잭션을 스크리닝하고 이러한 주소 중 하나가 포함되어 있으면 되돌릴 수 있습니다. 동시에 이상 탐지 - 정상적인 사용자 행동 외의 트랜잭션 식별 - 도 익스플로잇 방지에 합법적인 접근법으로 부상하고 있습니다. 공격자와 이상을 사전에 일관되게 식별할 수 있게 되면 트랜잭션 스크리닝의 문이 열리며, 프로토콜은 고위험 엔티티의 트랜잭션을 자동으로 되돌리거나 "예상 행동"을 크게 벗어나는 트랜잭션을 선택할 수 있습니다.

트랜잭션 스크리닝의 장기적 효과를 제한하는 기술적 과제 중 하나는 주소 가시성입니다. 현재 스마트 컨트랙트는 전체 콜 스택이 아닌 `msg.sender`와 `tx.origin`에만 가시성을 갖습니다. 공격자는 다양한 형태의 프록시를 사용하여 호출의 진정한 출처를 "난독화"하고 탐지를 우회할 수 있습니다. 이러한 우회 기술은 오늘날 사용되지 않지만, 트랜잭션 스크리닝이 더 보편화되면 해커들이 빠르게 채택할 것으로 예상됩니다.

이 제안은 콜 스택을 추적하고 EVM 실행의 특정 지점에서 요청 시 EVM 프리컴파일 컨트랙트를 통해 최신 목록을 노출함으로써 해커의 난독화 기술에 대한 가시성을 높이는 비침입적 방법을 도입합니다. 이는 컨트랙트가 진행하기 전에 더 많은 주소와 패턴을 스크리닝하는 데 도움이 됩니다.

## 사양

이 문서의 핵심어 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", "OPTIONAL"은 [RFC 2119](https://www.ietf.org/rfc/rfc2119.html) 및 [RFC 8174](https://www.ietf.org/rfc/rfc8174.html)에 설명된 대로 해석됩니다.

### 상수

| 이름                             | 값       |
|----------------------------------|----------|
| PRECOMPILE_ADDRESS               | TBD      |
| CALL_STACK_PER_CALL_COST         | 5        |
| PRECOMPILE_BASE_GAS_COST         | TBD      |
| PRECOMPILE_PER_CALL_COST         | 2        |

### Call

Call은 옵코드, 주소 및 함수 선택자로 정의됩니다.

선택자는 CALL 스타일 옵코드의 경우 콜 입력이 0이 아니면 콜 데이터의 처음 4바이트여야 합니다(MUST). CREATE 스타일 옵코드의 경우 빈 값이어야 합니다(MUST).

### CallStack

이것은 클라이언트 구현에 포함할 새로운 유형의 스택으로 제안되며 [이더리움 옐로우 페이퍼](https://ethereum.github.io/yellowpaper/paper.pdf)에 언급된 "message-call/contract-creation stack"을 기반으로 합니다. 실행에 사용되는 머신 스택과는 별개입니다.

CallStack은 콜 프레임당 새 머신 스택이 초기화되는 방식과 달리 트랜잭션 시뮬레이션당 초기화되어야 합니다(MUST).

새 콜 프레임을 생성하는 모든 작업은 CallStack에 Call을 푸시해야 하며(MUST) 콜 프레임이 종료된 후 팝해야 합니다(MUST). Cancun 하드 포크 사양에서 이 작업 목록은 `CALL`, `CALLCODE`, `DELEGATECALL`, `STATICCALL`, `CREATE` 및 `CREATE2`로 구성됩니다. 초기 트랜잭션 콜 프레임은 트랜잭션 실행이 시작될 때 항상 Call로 푸시되어야 하며 실행이 완료되면 팝되어야 합니다.

### 프리컴파일 컨트랙트

콜 스택은 클라이언트 구현에 정의된 프리컴파일 컨트랙트 인터페이스를 구현해야 하며(SHOULD) 콜 스택의 내용을 인코딩하여 반환해야 합니다(MUST).

인코더 로직은 Call 목록을 인코딩하기 위해 [Solidity 컨트랙트 ABI 사양](https://docs.soliditylang.org/en/latest/abi-spec.html)을 따라야 합니다(MUST). 이는 인코딩 표준과 Solidity 친화성을 제공하지만, 인코딩된 바이트가 구문 분석하기 쉬우므로 다른 언어 지원에 어려움을 주지 않습니다.

인코더는 아래 의사 코드와 같이 각 값을 32바이트 패딩 워드로 작성해야 합니다(MUST):

```
let b: ByteArray

b.append(0x20) // 기본 오프셋
b.append(len(CallStack))

for call in CallStack:
	b.append(call.Op)
	b.append(call.Address)
	b.append(call.Selector)
```

콜 스택에 다음과 같은 하나의 호출이 있다고 가정하면:
- 옵코드: `CALL` (`0xf1`)
- 주소: `0xafafafafafafafafafafafafafafafafafafafaf`
- 선택자: `0xabcdef12`
인코딩된 출력의 32바이트 워드는 다음과 같습니다:
```
0000000000000000000000000000000000000000000000000000000000000020 // 기본 오프셋
0000000000000000000000000000000000000000000000000000000000000001 // 콜 스택 크기
00000000000000000000000000000000000000000000000000000000000000f1 // CALL 옵코드
000000000000000000000000afafafafafafafafafafafafafafafafafafafaf // 주소
00000000000000000000000000000000000000000000000000000000abcdef12 // 선택자
```

원본 출력은 연속 배열이며 줄 구분이 없음에 유의하세요.

### 가스 비용

#### 콜 스택 가스 비용

콜 스택 구현은 EVM 실행에 최소한의 무시할 수 있는 오버헤드를 추가합니다. 각 콜 스택 항목은 머신 스택에 푸시되는 32바이트 워드보다 작습니다. 이러한 이유로 클라이언트는 트랜잭션 발신자에게 CallStack에 푸시/팝되는 Call당 총 `CALL_STACK_PER_CALL_COST`를 청구할 수 있습니다(MAY). 이 값은 `PUSH1`과 `POP`의 총 비용을 따르도록 선택되었습니다. `CALL_STACK_PER_CALL_COST`가 [CallStack](#callstack) 섹션에 나열된 옵코드의 비용에 비해 매우 작으므로 트랜잭션 발신자에게 이 금액을 청구하는 것은 선택 사항입니다(OPTIONAL).

#### 프리컴파일 컨트랙트 가스 비용

```
PRECOMPILE_BASE_GAS_COST + PRECOMPILE_PER_CALL_COST * len(CallStack)
```

프리컴파일 실행 시 인코더 오버헤드는 참조 구현을 사용 가능한 프리컴파일 컨트랙트와 비교 벤치마크할 때 합리적인 수준입니다. 이러한 이유로 `PRECOMPILE_BASE_GAS_COST`를 도입하여 인코딩 및 콜 스택의 기본 수준 오버헤드를 커버해야 합니다(SHOULD).

`PRECOMPILE_PER_CALL_COST` 값은 `PRECOMPILE_BASE_GAS_COST`가 0으로 선택되고 CallStack 크기가 1일 때 경쟁을 피하기 위해 `CALLER` 및 `ADDRESS` 옵코드의 가스 비용과 같거나 커야 합니다(SHOULD). 호출당 가스 비용을 갖는 것은 모든 호출에서 프리컴파일 비용을 확장하는 것과도 일치합니다.

### 프리컴파일 호출 예시

```solidity
contract CallStack {
    address constant PRECOMPILE_ADDRESS = address(...); // TBD

    struct Call {
        uint8 opCode;
        address addr;
        uint32 selector;
    }

    function getCallStack() internal returns (Call[] memory) {
        (, bytes memory returndata) = address(PRECOMPILE_ADDRESS).call(bytes(""));
        Call[] memory calls = abi.decode(returndata, (Call[]));
        return calls;
    }
}
```

## 근거

### `tx.origin`과 `msg.sender` 너머의 주소 관찰

이 기능은 `tx.origin`과 최신 `msg.sender` 사이의 실행 지점까지 트랜잭션에 관련된 다른 컨트랙트를 결정하는 데 유용합니다.

또한 블랙햇은 공격을 시작하기 전에 공격 컨트랙트를 배포하며, 이는 악성 컨트랙트를 스캔하고 탐지할 시간 프레임을 제공합니다. 공격 트랜잭션이 프록시에서 공격 컨트랙트로 `DELEGATECALL`하여 피해자 컨트랙트를 호출하면 피해자 컨트랙트가 관찰하는 `msg.sender`는 프록시 컨트랙트입니다(실제 악성 공격 컨트랙트가 아님). 콜 스택은 콜 스택에서 `DELEGATECALL`된 주소를 노출함으로써 이 회피를 깨뜨립니다.

### 회피 우려

로직 익스플로잇은 악성 컨트랙트가 직접 또는 간접적으로, 한 번 또는 여러 번 피해자 컨트랙트를 호출하는 형태로 발생합니다. 오프체인 탐지 메커니즘은 배포된 컨트랙트를 분석한 후 온체인 위험/평판 오라클을 업데이트할 수 있습니다. 이는 콜 스택을 사용하는 스크리닝 솔루션이 이상적으로 화이트리스트 오라클에서 각 주소를 확인하거나 컨트랙트 나이를 확인한 다음 부정적 평판 오라클에서 확인해야 함을 의미합니다. 이러한 검사와 결합하면 공격 컨트랙트 배포 및 공격 트랜잭션/호출의 어떤 타이밍도 공격자가 온체인 탐지를 회피하는 데 도움이 되지 않으며 이 제안의 추가 가시성 유용성 목표가 성공합니다. 그러나 이 제안은 프로토콜이 가진 가시성 불이익만 해결하고 공격자와 프로토콜의 트랜잭션 가시성을 동등하게 하려는 것이므로 이러한 검사가 어떻게 구현되어야 하는지에 대해 제안하거나 해결하려고 하지 않습니다.

### 계정 추상화 지원

설계상 콜 스택과 프리컴파일 컨트랙트는 [ERC-4337](https://ercs.ethereum.org/ERCS/erc-4337)에 설명된 계정 추상화를 지원합니다.

ERC-4337에서 UserOperations는 검증되어 실행될 단일 트랜잭션으로 번들되는 (비 EOA) 스마트 월렛에 대한 호출입니다. 참조 구현에서 각 UserOperation은 순차적으로 서로 격리되어 실행됩니다. 콜 스택 구현은 한 UserOperation의 주소를 다른 UserOperation에 노출하지 않음으로써 이 격리를 유지합니다. 스마트 월렛과 더 깊은 호출 대상은 다른 UserOperation 실행과 공통적으로 전역 싱글톤 EntryPoint 컨트랙트에만 노출됩니다.

### 패턴 검사

옵코드와 함수 선택자의 도움으로 컨트랙트는 트랜잭션의 호출 패턴에 대해 추론하는 보안 메커니즘을 구현할 수 있습니다. 우리는 이것이 투명한 온체인 이상 기반 위협 방지 솔루션 구현에서 한 걸음 더 나아간 것이라고 믿습니다.

### 주소 검사

이 제안은 트랜잭션에 관련된 주소에 대한 가시성을 향상시키지만 그러한 주소가 어떻게 검사되어야 하는지는 규정하지 않습니다. 이 콜 스택 프리컴파일을 컨트랙트 평판 및 나이 검사에 대한 보완 검사와 결합하면 트랜잭션 스크리닝이 더욱 향상되지만 그러한 검사도 이 제안의 범위 밖입니다.

### 조합성에 대한 영향

프리컴파일 자체는 조합성에 영향을 미치지 않습니다. 그러나 트랜잭션 스크리닝 솔루션과 함께 구현되고 활용되면 조합성이 영향을 받을 수 있습니다. 그럼에도 불구하고 각 프로토콜은 자체 위험을 관리하고 허용/불허하는 트랜잭션을 스스로 결정할 권리가 있다고 믿기 때문에 이는 수용 가능한 결과로 간주됩니다.

## 하위 호환성

콜 스택은 이전 실행에 영향을 미치지 않으며 합의 변경이 필요하지 않습니다. 그러나 프리컴파일 컨트랙트는 트랜잭션 실행 중 컨트랙트의 반응에 영향을 미칠 수 있으므로 모든 클라이언트가 업그레이드해야 합니다.

## 참조 구현

https://github.com/ethereum/go-ethereum/pull/28947

## 저작권

저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기되었습니다.
