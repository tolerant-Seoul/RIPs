---
rip: 7859
title: L2 실행 환경 내에서 L1 원점 정보 노출
description: L2 상태에서 L1 원점 데이터 및 과거 L2 블록 해시의 커밋 표준화
author: Ian Norden (@i-norden), Bo Du (@notbdu), Christian Angelopoulos (@christianangelopoulos), Mark Tyneway (@tynes)
discussions-to: https://ethereum-magicians.org/t/rip-7859-expose-l1-origin-information-inside-l2-execution-environment/22855
status: Draft
type: Standards Track
category: Core
created: 2025-01-10
requires:
---

## 개요

L2가 가장 최근에 브릿지 입력을 포함한 L1 블록에 대한 정보를 L2 실행 환경 내에서 노출하기 위한 사전 배포 스마트 컨트랙트.

## 동기

L2 블록은 시퀀서에 직접 전송된 L2 트랜잭션과 L1의 네이티브 브릿지에 대한 입금 트랜잭션에서 파생된 트랜잭션 모두로 구성됩니다. L2 블록에 L1 입금 입력을 포함하면 L2 블록과 그것이 생성된 L1 블록 간의 매핑이 생성됩니다. L2 블록의 상태에 기여한 최신 L1 블록을 해당 L2 블록의 `L1_ORIGIN`이라고 합니다.

L2 실행 환경에 `L1_ORIGIN`에 대한 정보를 포함하고 L2의 다른 컨트랙트에서 접근 가능하게 함으로써 L1에 대한 임의의 상태 주장을 검증하는 기능을 잠금 해제합니다.

이 기능은 [RIP-7755](./rip-7755.md)와 같은 크로스 L2 통신의 검증, [RIP-7789](https://ethereum-magicians.org/t/rip-7789-cross-rollup-contingent-transactions/21402)와 같은 L2 일관성 검사 시행, [RIP-7728](./rip-7728.md) 및 [ERC-3668](https://eips.ethereum.org/EIPS/eip-3668)와 같은 L1 읽기 검증을 포함한 광범위한 표준에 유용합니다. 일반적으로 L2 내에서 임의의 L1 상태, 스토리지, 트랜잭션 또는 영수증 데이터를 검증해야 하는 모든 컨트랙트에 유용합니다.

이것은 이더리움에 상태를 정산하는 다른 L2에 대한 주장을 검증하는 것으로 확장되어 추가 신뢰 가정 없이 L2 간 상호 운용성을 위한 간단한 메커니즘을 제공합니다. 이러한 L2가 과거 블록 해시를 포함하는 [EIP-2985](https://eips.ethereum.org/EIPS/eip-2935) 링 버퍼도 지원하면 L2가 출력을 희소하게만 정산하더라도 영수증 및 트랜잭션에 대한 주장을 검증하는 것이 가능해집니다.

## 사양

이 사양은 L2 실행 환경 내에서 현재 및 과거 `L1_ORIGIN`에 대한 정보에 접근하기 위한 컨트랙트 인터페이스를 정의하고 `L1_ORIGIN`의 의미를 제한하는 불변식을 정의합니다. 또한 롤업 간에 동일해야 하는 사전 배포 컨트랙트 주소를 지정합니다.

파생 중에 이 정보가 L2에 로드되는 정확한 메커니즘은 지정되지 않으며 기본 데이터 구조나 컨트랙트 내 레이아웃도 지정되지 않습니다. 롤업 스택에 존재하는 아키텍처 다양성을 더 잘 수용하여 시스템에 가장 적합한 방식으로 이 인터페이스를 구현할 수 있도록 이 수준의 사양을 피합니다.

그러나 이 인터페이스를 활용하는 프로토콜과 컨트랙트가 다른 롤업 스택 간에 공통 가정 집합에서 작동할 수 있도록 주어진 L2 블록에 대한 `L1_ORIGIN`의 정의에 몇 가지 제약을 정의해야 합니다.

### L1 원점 불변식

`L1_ORIGIN`의 의미에 대한 몇 가지 불변식을 정의하는 것으로 시작합니다.

1. 모든 L2 블록에는 `L1_ORIGIN`이 있습니다.
2. `L1_ORIGIN`은 정규 L1 블록이어야 합니다.
3. L2 블록 M보다 타임스탬프/높이가 큰 L2 블록 N의 경우 N의 `L1_ORIGIN`은 M의 L1 원점보다 높이/타임스탬프가 크거나 동일한 `L1_ORIGIN`을 공유해야 합니다.
4. L2 블록이 L1 입력에서 파생된 트랜잭션을 포함하는 경우 해당 L2 블록의 `L1_ORIGIN`은 L1 입력을 기여한 최신(가장 높은 높이/타임스탬프) L1 블록이어야 합니다.

위의 규칙에서 두 L2 블록이 동일한 `L1_ORIGIN`을 공유할 수 있으며 실제로 L1 블록타임보다 짧은 블록타임을 가진 모든 롤업에서 이것이 필요합니다.

위에서 순차적인 `L1_ORIGIN`이 연속적인 L1 블록일 필요가 없다는 것을 알 수 있습니다. 즉, L2 블록 N이 L1 블록 M을 `L1_ORIGIN`으로 가지면 L2 블록 N+1의 `L1_ORIGIN`은 L1 블록 M 또는 L1 블록 M+1일 필요가 없고 L1 블록 M+2, M+3, M+x 등이 될 수 있습니다. 이는 모든 L2 블록에서 L1 블록으로의 엄격한 매핑을 유지하지 않고 입금 트랜잭션을 포함할 때만 L1 블록을 고려하는 롤업 스택을 수용하기 위함입니다.

위의 불변식에서 발생하는 중요한 속성은 주어진 L2 블록에 대한 `L1_ORIGIN`이 재조직 시 해당 L2 블록의 재조직이 필요한 최신 L1 블록을 나타낸다는 것입니다.

### 컨트랙트 인터페이스

이러한 불변식이 갖춰진 상태에서 `L1_ORIGIN`에 대한 정보를 노출하기 위한 컨트랙트 인터페이스를 정의합니다.
이 인터페이스를 정의할 때 `L1_ORIGIN`에 대해 노출해야 하는 _어떤_ 정보인지도 정의합니다. `L1OriginSource` 인터페이스에 대해 총 9개의 메서드를 정의합니다. 이러한 메서드는 가장 유용하다고 생각되는 현재 및 과거 `L1_ORIGIN` 값에 대한 접근을 제공합니다: 블록 해시, 상태 루트, 영수증 루트, 트랜잭션 루트 및 블록 높이.

```solidity
interface L1OriginSource {
    function getL1OriginBlockHash() external view returns (bytes32 blockHash);
    function getL1OriginParentBeaconRoot() external view returns (bytes32 blockHash);
    function getL1OriginStateRoot() external view returns (bytes32 stateRoot);
    function getL1OriginReceiptRoot() external view returns (bytes32 receiptRoot);
    function getL1OriginTransactionRoot() external view returns (bytes32 transactionRoot);
    function getL1OriginBlockHeight() external view returns (uint256 blockHeight);

    function getL1OriginBlockHashAt(uint256 height) external view returns (bytes32 blockHash);
    function getL1OriginParentBeaconRootAt(uint256 height) external view returns (bytes32 blockHash);
    function getL1OriginStateRootAt(uint256 height) external view returns (bytes32 stateRoot);
    function getL1OriginReceiptRootAt(uint256 height) external view returns (bytes32 receiptRoot);
    function getL1OriginTransactionRootAt(uint256 height) external view returns (bytes32 transactionRoot);
}
```

과거 데이터 접근을 제공하는 후자의 메서드에 대해 데이터가 _최소_ 가장 최근 8192 L1 블록에 대해 사용 가능하도록 지정합니다.

### 사전 배포 컨트랙트 주소

위에서 정의된 인터페이스를 노출하는 컨트랙트는 모든 롤업에서 공통 주소에 존재해야 합니다. 이 주소는 `L1_ORIGIN_CONTRACT_ADDRESS`라고 하며 (tbd)로 설정됩니다.

## 근거

### 개별 필드 접근 vs 블록 해시 또는 비콘 블록 루트

블록 해시나 비콘 블록 루트만 노출하는 것에 비해 UX를 개선하고 가스 비용을 줄이기 위해 개별 헤더 필드가 노출됩니다. 블록 해시나 비콘 루트를 열어 내부의 개별 필드에 접근하려면 전체 프리이미지 또는 SSZ 증명을 콜데이터에 제공해야 합니다. 블록 해시의 프리이미지는 708바이트이고 깊이 3 이상의 머클 트리에 대한 SSZ 증명은 160+바이트입니다. 비콘 블록의 SSZ 머클 트리는 평균 깊이가 7 또는 8 레벨입니다.

L1 실행 헤더 또는 비콘 블록의 다른 필드를 검증하는 기능을 유지하기 위해 블록 해시와 비콘 블록 루트를 여전히 노출합니다.

### 과거 L1 원점 정보 접근

이 RIP에서 현재 `L1_ORIGIN` 정보뿐만 아니라 마지막 8190개의 `L1_ORIGIN`에 대한 접근을 허용하는 인터페이스를 제안합니다. 이는 최신 8191개의 `L1_ORIGIN`에 대한 뷰를 제공하며, EIP-4788 및 EIP-2935의 링 버퍼 길이와 일치하며(이에 의해 동기 부여됨). 이 L1 블록 수는 슬롯이 건너뛰어지지 않는다고 가정할 때 하나의 동기화 위원회 기간(256 에포크, 8192 슬롯)을 나타냅니다.

과거 `L1_ORIGIN` 정보에 대한 접근은 트랜잭션 및 영수증 루트가 블록 간에 누적되지 않으므로 과거 트랜잭션 또는 영수증에 대한 주장을 검증해야 하는 애플리케이션에 유용합니다. 또한 블록 간에 덮어쓰여지는 계정 또는 슬롯의 상태 및 스토리지를 검증하는 데 유용합니다. 또한 두 개의 다른 롤업의 두 블록이 현재 `L1_ORIGIN`을 공유하는지 여부에 관계없이 동일한 이더리움 기록 분기에서 빌드되었는지 확인하는 데 유용합니다.

### `L1_ORIGIN`의 정확성 시행

`L1OriginSource` 인터페이스 기반 컨트랙트에서 올바른 `L1_ORIGIN` 선택 및 스토리지는 불변 규칙에 따라 롤업 정산 시간에 시행되어야 합니다. 이러한 규칙이 L2 출력 검증 로직(예: 오류 증명 프로그램 또는 SNARK 회로)에 코드화된 파생 및 STF 로직의 일부가 됨으로써 수행됩니다.

### 정산 시간에 검증이 연기된 L1SLOAD와의 트레이드오프

EVM에 노출된 `L1_ORIGIN` 정보는 L1SLOAD 호출을 검증하는 데 사용될 수 있지만 L1SLOAD 호출을 검증하는 또 다른 방법은 정산 시간에 `L1_ORIGIN` 뷰의 정확성이 시행되는 방식과 유사하게 정산 시간에 검증을 연기하는 것입니다. 이 접근 방식은 포함 증명 또는 SNARK가 L2 EVM 내부에서 제공되고 평가될 필요가 없으므로 엄청난 가스 비용 절감을 제공합니다.

L1SLOAD가 지연된 검증으로 구현되면 `L1_ORIGIN`을 사용하여 L1 스토리지 데이터를 읽는 것에 비해 명확한 비용 이점을 제공합니다. 그럼에도 불구하고 여기에 설명된 `L1_ORIGIN`에 대한 접근은 `L1SLOAD`가 가지지 않는 몇 가지 속성을 나타냅니다:

1. 계정, 영수증/로그 및 트랜잭션에 대한 주장을 검증하는 데 사용할 수 있습니다.
2. 과거 L1 데이터에 대한 주장을 검증하는 데 사용할 수 있습니다.
3. 두 롤업이 동일한 이더리움 포크에서 빌드하고 있는지 확인하고 이를 크로스 롤업 트랜잭션 실행의 조건으로 시행하는 데 사용할 수 있습니다(RIP-7789).
4. L2 시퀀서가 L1에 대한 연결을 잃으면 L1SLOAD가 작동할 수 없습니다.
5. VM에서 L2와 L1 블록 간의 명시적 연결을 노출하면 롤업이 L1에서 재조직으로 인해 롤백해야 할 때를 추적하는 것이 더 간단해질 수 있습니다.
6. VM에서 L2와 L1 블록 간의 명시적 연결을 노출하면 외부 앱/엔티티(L2 VM 외부)가 L1 원점이 무엇인지 쉽게 알 수 있습니다.
7. L1SLOAD는 반환된 값의 일관성을 시행하기 위해 롤업이 `L1_ORIGIN` 뷰를 지원하도록 요청하는 것을 근거에 포함합니다.

종합하면, L1SLOAD를 지원하고 VM 내에서 `L1_ORIGIN` 뷰를 노출하는 것이 가장 좋을 것이라고 믿습니다.

### L3 컨텍스트에서의 의미

L3는 L2의 L2로 생각할 수 있으며, 이 컨텍스트에서 `L1_ORIGIN`은 대신 `L2_ORIGIN`입니다. `L2_ORIGIN`에 대한 동일한 정보가 L3 실행 환경 내에서 노출될 수 있으며 `L2_ORIGIN`의 의미에 대한 불변 규칙은 여기서 `L1_ORIGIN`에 대해 정의된 것과 동일합니다.

L3 내에서 L2의 `L1_ORIGIN` 정보를 `L2_ORIGIN` 뷰를 통해 접근할 수 있습니다. 왜냐하면 L2 내부의 `L1_ORIGIN`에 커밋하기 때문입니다. 이 접근은 `L1_ORIGIN` 데이터가 L2의 스토리지에 표현되는 방식에 특정적이며 `L2_ORIGIN` 상태 루트를 `L1_ORIGIN` 정보가 저장된 곳까지 여는 MMPT 증명을 제공해야 합니다. 이러한 이유로 L3 내에서 `L1_ORIGIN` 및 `L2_ORIGIN` 컨트랙트 인터페이스를 모두 지원하는 것이 유리할 수 있습니다.

## 하위 호환성

이 RIP는 EVM에 새로운 사전 배포 컨트랙트만 추가하므로 하위 호환성이 있습니다.

## 잠재적 구현 접근 방식

이 RIP에 대한 단일 구현을 지정하는 것을 피하지만 이 섹션을 사용하여 구현 방법에 대한 몇 가지 예를 제공합니다.

한 가지 접근 방식은 EIP-4788 및 EIP-2935에서와 같은 링 버퍼 구조를 사용하여 이러한 링 버퍼가 `L1_ORIGIN` 필드 값을 저장하는 것입니다. 이러한 버퍼는 시퀀서가 초기 L2 블록으로 `L1_ORIGIN`에서 입금을 처리할 때 사용 가능한 L1 컨텍스트를 사용하여 L2 블록 상단에서 시스템 호출 또는 트랜잭션으로 업데이트될 수 있습니다.

또 다른 접근 방식은 각 L1 헤더 필드를 자체 컨트랙트 변수에 저장하는 Optimism의 L1Block 컨트랙트와 같은 컨트랙트를 사용하는 것입니다. 이 컨트랙트는 이 RIP의 원래 영감입니다. 이 접근 방식에서 시퀀서는 현재 `L1_ORIGIN`에 대한 정보와 함께 L1Block 컨트랙트를 호출하는 L1 속성 트랜잭션을 초기 L2 블록의 상단에 포함합니다.

## 테스트 케이스

N/A

## 참조 구현

N/A

## 보안 고려사항

N/A

## 저작권

저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기되었습니다.
