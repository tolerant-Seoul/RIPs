---
rip: 7755
title: Cross-L2-Call
description: 크로스 L2 호출 촉진을 위한 컨트랙트 표준
author: Wilson Cusack (@WilsonCusack), Jack Chuma (@jackchuma)
discussions-to: https://ethereum-magicians.org/t/rip-contract-standard-for-cross-l2-calls-facilitation
status: Draft
type: Standards Track
category: RRC
created: 2024-08-11
---

## 개요

이 제안은 이더리움 생태계 내에서 크로스체인 호출을 촉진하기 위한 표준을 도입합니다. 이더리움과 그 롤업 간의 상태 공유를 활용하는 증명 시스템을 통해 신뢰 가정을 최소화하는 것을 목표로 합니다. 이 증명 시스템은 목적지 체인 호출 실행을 검증하여 요청된 트랜잭션을 처리하는 오프체인 에이전트에 대한 안전한 보상을 가능하게 합니다.

## 동기

크로스체인 상호작용은 현대 암호화폐 사용자 경험의 기본입니다. 이더리움 네트워크에 대한 현재 솔루션은 몇 가지 주요 한계에 직면해 있습니다:

1. 중앙화된 허가형 릴레이어에 대한 의존
1. 이더리움 및 그 롤업 외부 프로토콜에 대한 의존
1. 실행에 대한 직접적인 제어를 제한하는 추상화된 인텐트 기반 아키텍처

공유 실행 환경에 상태를 기록하는 이더리움 L2는 대안을 제공하기에 적합합니다. EVM 체인 사용자는 크로스체인 호출을 실행하기 위한 공개적이고 분산된 유틸리티에 접근할 수 있어야 합니다.

모든 EVM 체인에서 사용자는 실행 확률에 영향을 미치는 보상 메커니즘을 활용하면서 다른 EVM 체인에서 호출을 시작할 수 있어야 합니다.

사용자는 호출이 실행된 경우에만 보상이 제공된다는 완전한 확신을 가져야 합니다. 이 확신은 온체인 정보에만 의존해야 합니다.

## 사양

시스템은 세 가지 주요 구성요소에 의존합니다:

- 메시지 전달 컨트랙트: 메시지 송수신 및 이행자 보상 처리를 위한 소스 체인 `Outbox`와 목적지 체인 `Inbox`.
- 릴레이어: 사용자를 대신하여 목적지 체인으로 메시지를 중계하는 정교한 오프체인 행위자("이행자"라고 함).
- 정산 레이어: 소스 체인에서 이행자 보상을 허용하기 위해 목적지 체인 호출 전달을 검증하는 메커니즘.

이 제안은 모든 이더리움 L2가 이더리움 메인넷에 상태 표현을 게시한다고 가정합니다. 실행 환경 내에서 L1 상태를 노출하는 L2는 고유한 능력을 얻습니다: 이더리움에 연결된 다른 L2의 상태를 증명할 수 있습니다. 이 기본 속성은 아래에 자세히 설명된 EIP-1186 스토리지 증명을 통한 신뢰 없는 정산 레이어를 가능하게 합니다.

### 요청 흐름

![image](../assets/rip-7755/happy_case.png "정상 케이스 흐름")

1. 사용자가 보상 자금과 함께 요청을 `Outbox`에 제출
1. `Outbox`가 발견 이벤트 발행
1. 이행자가 필요한 실행 자금을 포함하여 목적지 체인의 `Inbox`로 요청 중계
1. `Inbox`가 요청된 크로스체인 호출 실행
1. `Inbox`가 컨트랙트 스토리지에 실행 영수증 저장
1. 지정된 지연 후 이행자가 `Outbox`에 증명 제출
1. 증명 검증 성공 시 이행자에게 보상 지급

> [!NOTE]
>
> - 다음 사양은 Solidity `0.8.24` (이상) 구문을 사용합니다.

### 데이터 구조

#### Call

목적지 체인의 트랜잭션에 대한 저수준 호출 사양을 나타냅니다.

필드:

- `to`: bytes32 형식으로 변환된 호출할 주소
- `data`: 호출을 위한 콜데이터
- `value`: 호출을 위한 네이티브 자산 값

```solidity
struct Call {
    bytes32 to;
    bytes data;
    uint256 value;
}
```

### Outbox

원본 체인에 배포된 Outbox 컨트랙트는 크로스체인 호출 요청과 보상 배포를 관리합니다. 스토리지 증명을 통해 요청 이행을 검증하며 다음 인터페이스를 구현해야 합니다.

#### 이벤트

##### MessagePosted

사용자가 크로스체인 호출 요청을 시작할 때 발행됩니다.

**매개변수:**

- `messageId` (bytes32, indexed): 메시지 요청의 Keccak256 해시
- `sourceChain` (bytes32): 소스 체인의 체인 식별자
- `sender` (bytes32): 발신자의 계정 주소
- `destinationChain` (bytes32): 목적지 체인의 체인 식별자
- `receiver` (bytes32): 수신자의 계정 주소
- `payload` (bytes): 목적지 체인에서 실행될 인코딩된 메시지
- `attributes` (bytes[]): 메시지에 포함될 속성

```solidity
event MessagePosted(
    bytes32 indexed messageId,
    bytes32 sourceChain,
    bytes32 sender,
    bytes32 destinationChain,
    bytes32 receiver,
    bytes payload,
    bytes[] attributes
);
```

##### CrossChainCallCompleted

이행자가 크로스체인 호출 실행에 대한 보상을 성공적으로 청구할 때 발행됩니다.

**매개변수:**

- `messageId` (bytes32, indexed): 메시지 요청의 Keccak256 해시
- `submitter` (address): 청구한 이행자의 주소

```solidity
event CrossChainCallCompleted(bytes32 indexed messageId, address submitter);
```

##### CrossChainCallCanceled

만료된 요청이 취소될 때 발행됩니다.

**매개변수:**

- `messageId` (bytes32, indexed): 메시지 요청의 Keccak256 해시

```solidity
event CrossChainCallCanceled(bytes32 indexed messageId);
```

#### 메서드

##### sendMessage

크로스체인 호출 요청을 시작합니다.

**요구사항:**

- `MessagePosted`를 발행해야 합니다
- 컨트랙트에 보상 금액을 잠가야 합니다
- 수신자는 목적지 체인의 `Inbox` 컨트랙트 또는 ERC-4337 `EntryPoint` 컨트랙트로 지정해야 합니다
- 페이로드는 인코딩된 `Call` 배열 또는 인코딩된 `UserOp`입니다
- 계정 추상화 고려사항은 [크로스체인 UserOps](#크로스체인-사용자-작업)를 참조하세요

```solidity
function sendMessage(
    bytes32 destinationChain,
    bytes32 receiver,
    bytes calldata payload,
    bytes[] calldata attributes
) external payable returns (bytes32);
```

##### claimReward

이행자가 성공적인 크로스체인 실행 증명을 제공하여 보상을 청구할 수 있게 합니다.

**요구사항:**

- 증명을 검증해야 합니다
- `CrossChainCallCompleted` 이벤트를 발행해야 합니다
- 지정된 `payTo` 주소로 보상을 전송해야 합니다

```solidity
function claimReward(
    bytes32 destinationChain,
    bytes32 receiver,
    bytes calldata payload,
    bytes[] calldata attributes,
    bytes calldata proof,
    address payTo
) external;
```

##### cancelRequest

만료된 요청을 취소하고 보상을 환불합니다.

**요구사항:**

- 요청 만료를 검증해야 합니다
- `CrossChainCallCanceled`를 발행해야 합니다
- 원래 요청자에게 보상을 환불해야 합니다

```solidity
function cancelMessage(
    bytes32 destinationChain,
    bytes32 receiver,
    bytes calldata payload,
    bytes[] calldata attributes
) external;
```

### Inbox

목적지 체인의 Inbox 컨트랙트는 요청된 호출의 라우터 역할을 하고 요청 이행 영수증을 유지합니다.

#### 데이터 구조

##### FulfillmentInfo

이 구조체는 요청 이행에 대한 세부 정보를 보유합니다.

필드:

- `timestamp`: 요청이 이행된 블록 타임스탬프.
- `fulfiller`: 호출을 성공적으로 완료한 엔티티의 주소.

```solidity
struct FulfillmentInfo {
    uint96 timestamp;
    address fulfiller;
}
```

#### 이벤트

##### CallFulfilled

크로스체인 호출 요청이 이행될 때 이 이벤트가 발행됩니다.

**매개변수**:

- `messageId`: 메시지 요청의 keccak256 해시.
- `fulfilledBy`: 호출을 성공적으로 완료한 엔티티의 주소.

```solidity
event CallFulfilled(bytes32 indexed messageId, address indexed fulfilledBy);
```

#### 메서드

##### fulfill

이 메서드는 요청된 호출을 지정된 목적지로 라우팅하고 이행 영수증을 기록합니다.

**요구사항:**

- 요청된 `Call`을 실행해야 합니다
- `CallFulfilled` 이벤트를 발행해야 합니다
- `FulfillmentInfo`가 저장되면 영수증은 불변입니다
- 모든 호출이 성공한 경우에만 `FulfillmentInfo`를 저장해야 합니다

참고: 호출자는 커스텀 이행자 주소를 지정하여 다른 주소가 보상을 청구할 수 있게 합니다.

```solidity
function fulfill(
    bytes32 sourceChain,
    bytes32 sender,
    bytes calldata payload,
    bytes[] calldata attributes,
    address fulfiller
) external payable;
```

### 스토리지 증명 검증

스토리지 증명 검증은 Outbox 컨트랙트 내에서 이행자에게 보상을 지급하기 전에 실행 영수증이 목적지 체인 `Inbox` 스토리지에 존재하는지 확인하는 데 사용됩니다. 스토리지 증명 검증 구현은 체인별로 다르기 때문에 `Outbox` 컨트랙트의 `claimReward` 함수는 `proof` 매개변수를 일반 `bytes` 타입으로 받습니다. 구현 간 특정 증명 형식은 다를 수 있지만 모두 이 핵심 검증 순서를 따라야 합니다:

![image](../assets/rip-7755/state_root_sharing.png "스토리지 증명 검증")

> [!NOTE]
> 다이어그램의 시각적 요소:
>
> - 네트워크: 회색 배경
> - 컨트랙트: 보라색 배경
> - 스토리지 값: 노란색 배경
>
> 체인 정의:
>
> - 체인 A: 소스 체인
> - 체인 B: 목적지 체인
>
> 이 예시는 L2 -> L1 -> L2 경로에 대한 검증 단계를 보여줍니다

검증 단계:

1. 증명의 비콘 루트가 체인 A의 실행 환경에 노출된 루트와 일치하는지 검증합니다.
1. 비콘 루트에 대해 L1 실행 클라이언트의 상태 루트를 검증합니다.
1. L1 실행 클라이언트의 상태 루트에 대해 체인 B의 롤업 컨트랙트 스토리지 루트를 검증합니다.
1. 롤업 컨트랙트 스토리지 루트에 대해 체인 B의 상태 루트를 검증합니다.
1. 체인 B의 상태 루트에 대해 체인 B의 inbox 컨트랙트 스토리지 루트를 검증합니다.
1. 체인 B의 inbox 컨트랙트 스토리지 루트에 대해 지정된 스토리지 키의 `FulfillmentInfo` 구조체를 검증합니다.

**중요한 구현 참고사항:**
일부 L2 체인은 상태 루트를 직접 저장하는 대신 L1에 "출력 루트"를 저장합니다. 이러한 경우 4단계와 5단계 사이에 추가 검증 단계가 필요합니다. 이 단계는:

1. 목적지 체인의 상태 루트를 제공해야 합니다
2. 상태 루트와 보조 데이터를 사용하여 출력 루트를 도출하는 체인별 로직을 적용해야 합니다
3. 도출된 출력 루트가 L1의 목적지 체인 롤업 컨트랙트에서 증명된 값과 일치하는지 검증해야 합니다

### 메시지 커스터마이제이션

메시지 또는 요청 구조는 목적지 체인의 메시지 전달 동작과 검증을 위한 정산 시스템을 커스터마이즈할 수 있는 유연성을 허용합니다. 이 유연성은 ERC-7786에서 영감을 받은 속성을 사용하여 달성됩니다. 각 속성은 4바이트 선택자로 시작하고 abi 인코딩된 데이터가 뒤따르는 바이트 문자열입니다.

#### [필수] Nonce 속성

- 선택자: `0xce03fdab`
- 내용:
  - Nonce 값 (`uint256`)

nonce 속성은 모든 요청이 고유하도록 보장하여 메시지 ID 충돌을 방지합니다. Outbox는 제공된 nonce의 존재와 정확성을 검증할 것으로 예상됩니다.

#### [필수] Delay 속성

- 선택자: `0x84f550e0`
- 내용:
  - 최종성 지연 (`uint256`)
  - 만료 (`uint256`)

delay 속성은 요청 만료 설정에 필요합니다. 선택적으로 이행자가 보상을 너무 빨리 청구하는 것을 방지하는 데 사용되는 최종성 지연을 설정할 수도 있습니다. 이는 증명이 옵티미스틱 롤업의 최종화되지 않은 상태에 대한 것일 경우 필요합니다. 증명이 최종화된 상태에 대한 것이면 최종성 지연은 불필요하며 Outbox에서 무시할 수 있습니다. 만료는 모든 경우에 필요하며 사용자가 자금을 회수할 가능성 없이 이행자가 요청 전달 후 보상을 청구할 충분한 시간을 갖도록 보장하는 데 사용됩니다.

##### 최종성 지연이 있는 요청 흐름

![image](../assets/rip-7755/request_flow_finality_delay.png "최종성 지연이 있는 요청 흐름")

##### 취소된 요청 흐름

![image](../assets/rip-7755/cancelled_request.png "만료된 요청이 취소됨")

#### [선택] Precheck 속성

- 선택자: `0xbef86027`
- 내용:
  - 목적지 체인 Precheck 컨트랙트 주소 (`bytes32`)

precheck 메커니즘은 요청자가 요청이 전달되기 위해 일부 목적지 체인 조건이 참이어야 함을 보장할 수 있게 합니다. 이는 임의의 조건을 검증하는 precheck 컨트랙트를 목적지 체인에 배포하여 수행됩니다. precheck 컨트랙트는 다음 인터페이스를 구현해야 하며 요청 이행 전에 호출됩니다.

![image](../assets/rip-7755/call_delivery_precheck.png "precheck가 있는 호출 전달")

**요구사항:**

- 검증 조건이 충족되지 않으면 되돌려야 합니다
- 크로스체인 요청과 호출자 주소를 매개변수로 포함합니다. 호출자는 `Inbox`에 트랜잭션을 제출한 이행자의 주소입니다.

```solidity
function precheckCall(
    bytes32 sourceChain,
    bytes32 sender,
    bytes calldata payload,
    bytes[] calldata attributes,
    address caller
) external view;;
```

#### [선택] MagicSpend 속성

- 선택자: `0x92041278`
- 내용:
  - 통화 컨트랙트 주소 (`address`)
  - 통화 금액 (`uint256`)

magic spend 속성은 호출 실행 중에 페이마스터로부터 자금을 요청할 수 있게 합니다. 이는 호출 실행에 어떤 통화가 필요한지 명확하게 하고 이행자가 개별 호출을 파싱하여 직접 결정해야 하는 복잡성을 제거하므로 이행자에게 유익할 수 있습니다.

![image](../assets/rip-7755/call_delivery_magicspend.png "magic spend 요청이 있는 호출 전달")

이는 다음 인터페이스를 구현하는 페이마스터 컨트랙트에 대한 접근이 필요합니다. 이는 페이마스터 컨트랙트가 inbox에 의해 소유된 경우에만 안전할 수 있습니다.

**요구사항:**

- `fulfiller`가 페이마스터에서 `token`의 잔액이 부족하면 되돌려야 합니다
- `Inbox` 컨트랙트로 `amount`의 `token`을 보내야 합니다

```solidity
function fulfillerWithdraw(address fulfiller, address token, uint256 amount) external;
```

#### [선택] Reward 속성

- 선택자: `0xa362e5db`
- 내용:
  - 자산 컨트랙트 주소 (`bytes32`)
  - 자산 금액 (`uint256`)

reward 속성은 요청자가 이행자 보상으로 outbox 컨트랙트에 잠길 보상을 지정할 수 있게 합니다.

#### [선택] Inbox 속성

- 선택자: `0xbd362374`
- 내용:
  - 목적지 체인의 Inbox 컨트랙트 주소 (`bytes32`)

inbox 속성은 목적지 체인의 7755 `Inbox` 컨트랙트를 지정합니다. 표준 요청(페이로드가 인코딩된 `Call` 배열인 요청)의 경우 `receiver`가 `Inbox` 컨트랙트이므로 이것이 필요하지 않습니다. 그러나 크로스체인 UserOps의 경우 이 속성은 필수로 간주되어야 합니다.

#### [선택] Requester 속성

- 선택자: `0x3bd94e4c`
- 내용:
  - 요청자 주소 (`bytes32`)

요청자 주소가 7755 요청에 연결될 수 있게 합니다.

#### [선택] L2 Oracle 속성

- 선택자: `0x7ff7245a`
- 내용:
  - L2 Oracle 주소 (`address`)

L2 Oracle 속성은 요청자가 L1의 롤업 컨트랙트 주소를 지정할 수 있게 합니다. 이는 목적지 체인의 상태 표현을 저장해야 하는 컨트랙트이며 정산 레이어 검증 내에서 사용됩니다.

### 크로스체인 사용자 작업

ERC-4337에서 도입된 계정 추상화(AA) 기술은 여러 블록체인 네트워크에서 널리 채택되었습니다. 이 성공은 RRC-7755 표준이 여러 과제를 해결하기 위해 활용할 수 있는 강력한 생태계를 만들었습니다 - 가장 중요한 것은 허가된 크로스체인 호출을 가능하게 하는 것입니다.

#### UserOp 통합

7755 요청이 목적지 체인의 `EntryPoint` 컨트랙트에 제출된 4337 UserOp인 경우 호출 실행이 사용자의 스마트 계정을 통해 직접 라우팅되므로 `msg.sender` 문제를 해결합니다. 여기서 주의할 점은 7755 `Inbox` 컨트랙트가 4337 페이마스터가 되어야 한다는 것입니다:

1. 스마트 계정이 트랜잭션에 대한 가스를 지불할 필요를 제거
1. UserOp이 성공할 때 실행 영수증을 생성하는 Inbox 컨트랙트의 핵심 불변성 유지

이러한 이유로 메시지 페이로드는 인코딩된 `Call` 배열 대신 인코딩된 4337 `UserOp`일 수도 있습니다. 메시지가 UserOp인 경우 메시지의 `receiver` 필드는 목적지 체인의 `EntryPoint` 컨트랙트를 가리켜야 하며 목적지 체인의 Inbox 컨트랙트를 지정하려면 Inbox 속성이 필수가 됩니다.

#### UserOp 속성 및 실행 흐름

UserOps를 사용할 때 7755 메시지의 attributes 배열은 비어 있어야 합니다. 속성이 UserOp 자체에 내장될 것으로 예상되기 때문입니다. 이를 통해 메시지 ID 유도는 기존 4337 UserOp 해시 유도 메커니즘을 차용할 수 있습니다.

![image](../assets/rip-7755/call_delivery_userop.png "UserOp에 대한 호출 전달")

UserOp 기반 크로스체인 호출의 실행 흐름은 다음과 같습니다:

1. 이행자가 목적지 체인 `EntryPoint` 컨트랙트에 UserOp을 제출합니다. UserOp은 7755 `Paymaster` 컨트랙트를 활용할 것으로 예상됩니다.
2. `EntryPoint`가 사용자의 Smart Account에서 `validateUserOp`을 호출합니다.
3. `EntryPoint`가 7755 `Paymaster` 컨트랙트에서 `validatePaymasterUserOp`을 호출합니다. `Paymaster` 컨트랙트는 이행자가 가스 지불 + 호출 실행을 위한 대출에 필요한 자금을 사전 예치했는지 확인합니다.
4. `EntryPoint`가 요청된 호출을 실행하기 위해 사용자의 Smart Account에서 `exec`를 호출합니다.
5. Smart Account가 호출 실행에 자금이 필요한 경우 `Paymaster`에서 `withdrawGasExcess`를 호출합니다.
6. `Paymaster`는 검증 단계에서 승인된 자금만 해제합니다. 이 자금은 Smart Account로 전송됩니다.
7. Smart Account가 요청된 호출을 실행합니다.
8. `EntryPoint`가 호출 실행 결과와 함께 `Paymaster`에서 `postOp`을 호출합니다.
9. 호출이 성공하면 `Paymaster`가 7755 `Inbox` 컨트랙트를 호출하여 요청에 대한 실행 영수증을 생성합니다.
10. `Inbox`가 스토리지에 실행 영수증을 저장합니다.

#### 페이마스터 구현

더 구체적으로, UserOp 내에서 `paymasterAndData` 필드는 다음과 같이 인코딩되어야 합니다:

`paymasterAndData`의 처음 20바이트는 Paymaster 컨트랙트 주소를 나타내고, 그 다음 32바이트 검증 데이터 필드가 있으며, 나머지 바이트에는 인코딩된 7755 속성이 포함됩니다.

```solidity
(bytes[] memory attributes) = abi.decode(userOp.paymasterAndData[52:], (bytes[]));
```

Paymaster 컨트랙트는 UserOps를 검증하고 지불하기 위해 ERC-4337 페이마스터 인터페이스도 구현해야 합니다:

```solidity
function validatePaymasterUserOp(
    UserOperation calldata userOp,
    bytes32 userOpHash,
    uint256 maxCost
) external returns (bytes memory context, uint256 validationData);

function postOp(
    PostOpMode mode,
    bytes calldata context,
    uint256 actualGasCost
) external;
```

검증 중에 Paymaster 컨트랙트는:

1. `paymasterAndData`에서 속성을 디코딩하고 검증해야 합니다
1. 속성에 precheck 조건이 포함된 경우 선택적으로 검증해야 합니다
1. 이행자가 요청된 호출을 후원하기에 충분한 자금을 사전 예치했는지 확인해야 합니다
1. 실행 후 Inbox 스토리지에 이행 정보를 기록해야 합니다

이 접근 방식은 크로스체인 UserOps가 ERC-4337의 계정 추상화 기능을 활용하면서 표준 7755 호출과 동일한 보안 보장을 유지하도록 합니다.

### 메시지 ID 유도

**표준 요청:**

```solidity
keccak256(abi.encode(sourceChain, sender, destinationChain, receiver, payload, attributes))
```

**UserOp 요청:**

```solidity
keccak256(abi.encode(userOp.hash(), receiver.bytes32ToAddress(), uint256(destinationChain)));
```

## 근거

크로스체인 호출 실행에 대한 스토리지 기반 증명 검증은 이더리움과 그 롤업을 넘어서는 추가 신뢰 가정 없이 암호화 보장을 제공합니다. Inbox 컨트랙트의 불변 스토리지 설계는 실행 영수증이 한번 저장되면 증명 복잡성을 증가시키지 않고 미래의 어느 시점에서도 영구적이고 검증 가능하게 유지되도록 합니다.

표준은 특히 미래의 비EVM 체인 통합을 위해 대부분의 주소 타입을 `bytes32`로 변환하여 순방향 호환성을 유지합니다.

`rewardAsset`과 `rewardAmount`의 분리는 크로스체인 트랜잭션 통화와 독립적으로 다양한 보상 타입을 지원할 수 있게 합니다. 예를 들어, USDC의 크로스체인 전송을 실행하는 동안 보상은 ETH로 표시될 수 있습니다. 이행자는 호출을 처리하기 전에 보상 값이 트랜잭션 비용을 적절히 보상하는지 검증해야 합니다.

`finalityDelaySeconds` 매개변수는 증명 제출 전에 목적지 체인 최종성에 대한 충분한 신뢰를 보장하여 보안을 향상시킵니다. 이는 증명자가 최종화되지 않은 상태에 의존하는 경우에만 관련이 있으며 이 보안 조치는 L1 및 L2 합의 메커니즘이 발전함에 따라 적응할 수 있습니다.

`l2Oracle` 사양은 호환 가능한 체인 간에 증명 검증 재사용을 가능하게 합니다. 예를 들어, 여러 OP Stack 체인이 별도의 `l2Oracle` 인스턴스를 유지하면서 단일 Outbox 컨트랙트를 공유할 수 있습니다.

## 보안 고려사항

### 스토리지 증명 검증 위험

모든 체인의 하드 포크는 스토리지 증명 검증 호환성을 손상시킬 수 있습니다. 이 비호환성은 다음에서 발생할 수 있습니다:

- 체인의 상태 레이아웃 변경 (예: Merkle Patricia Trie 스토리지에서 마이그레이션)
- L1 데이터 스토리지 메커니즘 수정

**중요한 영향**: 호환되지 않는 스토리지 증명 검증은 Outbox 컨트랙트에 자금이 잠기는 결과를 초래할 수 있습니다. 이행자는 지원되는 체인의 예정된 하드포크를 적극적으로 모니터링해야 합니다.

### 이행자 위험 관리

시스템 아키텍처는 주요 위험 노출을 사용자에서 이행자로 이동시킵니다. 주요 위험은 다음과 같습니다:

1. **재조직 위험**: 즉각적인 요청 이행은 이행자를 잠재적인 소스 체인 재조직에 노출시키며, 이는 다음을 초래할 수 있습니다:

   - 트랜잭션 취소
   - 토큰 전송 손실

2. **요청 검증 요구사항**

최소한, 이행자는 다음 기준에 따라 모든 요청자 설정 필드를 검증해야 합니다:

| 조건                              | 설명                                                                                                                                                                                                                                                                                                                                   |
| -------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 목적지 체인 확인          | 요청의 지정된 목적지 체인이 소스 체인의 Outbox와 호환되는지 확인합니다. 예: OP Stack outbox에서 시작하여 Arbitrum으로 향하는 요청은 유효하지 않습니다.                                                                                                                                                  |
| 목적지 체인 수신자 확인 | 요청의 목적지 체인 수신자가 인식된 Inbox 또는 Entrypoint 주소인지 확인합니다.                                                                                                                                                                                                                                             |
| L2 Oracle 확인                  | 지정된 `L2Oracle`이 목적지 체인에 유효한지 확인합니다. 목적지 체인이 상태를 게시하는 이더리움 메인넷의 롤업 컨트랙트 주소여야 합니다.                                                                                                                               |
| 최종성 지연 확인             | 최종성 지연이 너무 짧으면 요청자가 상태가 L1에서 증명 가능해지기 전에 보상을 회수할 수 있어 자금이 효과적으로 도난당할 수 있습니다. 지연이 너무 길면 잠긴 자금의 기회 비용이 높아집니다.                                                                                                        |
| 제안된 보상 확인       | 이행자는 보상이 목적지 체인에서 요청을 제출하기 위한 예상 가스 비용, 소스 체인에서 요청을 증명하고 보상을 청구하기 위한 예상 가스 비용, 목적지 체인에서 실행에 필요한 자금, 최종성 지연 동안 잠긴 자금의 기회 비용을 커버하는지 확인해야 합니다 |
| UserOp 검증                        | 요청이 UserOp인 경우 페이마스터 주소가 인식된 7755 페이마스터인지 확인합니다                                                                                                                                                                                                                                                       |
| 이행자 자금 확인              | 이행자는 목적지 체인 호출 실행에 필요한 모든 자금을 커버할 충분한 잔액이 있는지 확인해야 합니다                                                                                                                                                                                                                        |

## 저작권

저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기되었습니다.
