---
rip: 7560
title: 네이티브 계정 추상화
description: 상위 계층 인프라에 의존하지 않고 합의 계층 프로토콜 변경을 도입하는 계정 추상화 제안
author: Vitalik Buterin (@vbuterin), Yoav Weiss (@yoavw), Alex Forshtat (@forshtat), Dror Tirosh (@drortirosh), Shahaf Nacson (@shahafn)
discussions-to: https://ethereum-magicians.org/t/rip-7560-native-account-abstraction/16664
status: Draft
type: Standards Track
category: Core
created: 2023-09-01
requires: 7702
---

## 개요

[EIP-2938](https://eips.ethereum.org/EIPS/eip-2938)과 [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337)을 포괄적인 네이티브 계정 추상화 제안으로 결합합니다.

이더리움 트랜잭션 범위를 검증, 실행, 트랜잭션 후 로직의 여러 단계로 분할하는 것을 제안합니다.
트랜잭션 유효성은 트랜잭션의 검증 단계 결과에 의해 결정됩니다.

또한 인가와 가스 수수료 지불 목적의 트랜잭션 검증을 분리하여,
컨트랙트 B가 계정 컨트랙트 A에서 실행될 트랜잭션의 가스를 지불할 수 있도록 합니다.

이점은 신흥 ERC-4337 생태계와의 하위 호환성을 유지하면서 네이티브 계정 추상화의
장기 목표를 달성하는 것입니다.

## 동기

ERC-4337은 순수한 자발적 ERC로서 많은 것을 할 수 있습니다. 그러나 계정 추상화를 달성하는
프로토콜 외부 방식은 네이티브 지원에 비해 몇 가지 단점에 직면합니다. 다음은
진정한 프로토콜 내 솔루션에 비해 약한 몇 가지 주요 영역입니다:

* 기본 `UserOperation`에 대해 약 42k의 추가 가스 오버헤드(기본 트랜잭션의 약 21k와 비교).

* 트랜잭션을 대상으로 하고 `UserOperations`을 놓칠 수 있는 crLists와 같은 프로토콜 내 검열 저항
  기술의 이점 감소.

* 상당히 작은 참여 노드 집합과 `eth_sendRawTransactionConditional`과 같은 비표준 RPC 메서드에 의존.

* `tx.origin`을 사용할 수 없거나 번들러의 의미 없는 주소를 반환하므로 이에 의존하는 컨트랙트 사용 불가.

EIP-2938은 계정 추상화에 대한 매우 성숙한 대안 접근법을 정의합니다. 그러나 프로토콜 변경 없이
프로덕션에서 사용되고 있는 ERC-4337의 아키텍처로 잘 변환되지 않습니다.
따라서 EIP-2938의 구현은 ERC-4337 사용으로 얻은 프로덕션 경험과
이와의 하위 호환성 유지로부터 큰 이점을 얻지 못합니다.

또한 미래 어느 시점에 이더리움의 모든 EOA가 사전 배포된 스마트 컨트랙트로 대체될 가능성이 있습니다.
그러나 이는 프로토콜에 네이티브 계정 추상화를 추가하지 않으면 불가능합니다.

## 사양

### 상수

| 이름                   | 값                  |
|------------------------|---------------------|
| FORK_BLOCK             | TBD                 |
| AA_TX_TYPE             | TBD                 |
| AA_ENTRY_POINT         | `address(7560)`     |
| AA_SENDER_CREATOR      | `address(ffff7560)` |
| AA_BASE_GAS_COST       | 15000               |
| VERSION                | 1                   |
| MAX_CONTEXT_SIZE       | 65536               |
| MAX_REVERT_REASON_SIZE | 1024                |


### 정의

* *트랜잭션*:
  계정에 의해 시작되고 입력 매개변수 집합으로 표현되는 동작입니다.
  이 동작은 블록에 포함될 때 이더리움 블록체인의 상태를 변경합니다.
* *RIP-7560 트랜잭션*:
  스마트 컨트랙트 계정에 의해 시작되고 [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) 호환 트랜잭션 엔벨로프 객체로 표현되는 동작입니다.
* *RIP-7560 콜 프레임*:
  특정 주소에 대한 단일 최상위 호출과 주어진 데이터로 표현되는 EVM 코드 실행의 단일 원자적 요소입니다.
  RIP-7560 콜 프레임은 내부 콜 프레임도 포함할 수 있지만, 이들은 "RIP-7560 콜 프레임"으로 지칭되지 않습니다.
  RIP-7560 콜 프레임은 성공하거나 되돌릴 수 있습니다.
* *RIP-7560 트랜잭션 단계*:
  RIP-7560 트랜잭션 흐름의 단일 단계를 형성하는 RIP-7560 콜 프레임 집합입니다.
  RIP-7560 트랜잭션에는 *검증*과 *실행*의 두 단계가 있습니다.
* *페이마스터*:
  RIP-7560 트랜잭션에서 가스를 지불하는 것이 유일한 역할인 스마트 컨트랙트입니다.

### 새로운 트랜잭션 타입

AA_TX_TYPE 타입의 새로운 [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718) 트랜잭션이 도입됩니다.
이 타입의 트랜잭션은 "AA 트랜잭션"이라고 합니다. 페이로드는 다음과 같이 해석됩니다:

```

AA_TX_TYPE || rlp([
  chainId,
  nonceKey, nonceSequence,
  sender, senderValidationData,
  deployer, deployerData,
  paymaster, paymasterData,
  executionData,
  builderFee,
  maxPriorityFeePerGas, maxFeePerGas,
  validationGasLimit, paymasterValidationGasLimit, paymasterPostOpGasLimit
  callGasLimit,
  accessList,
  authorizationList
])

```

```
authorizationList = [[chain_id, address, nonce, y_parity, r, s], ...]
```


이 트랜잭션의 기본 가스 비용은 "내재적" ECDSA 서명 검증이 없음을 반영하여 21000 대신 `AA_BASE_GAS_COST`로 설정됩니다.

`authorizationList` 매개변수는 [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702)에서 정의된 것과 정확히 동일한 동작을 합니다.

### RIP-7560 트랜잭션 정의:

다음 표는 RIP-7560 트랜잭션의 전체 필드 목록을 나타냅니다:

| 이름                          | 타입           | 설명                                                                         |
|-------------------------------|----------------|-------------------------------------------------------------------------------------|
| sender                        | DATA, 20 Bytes | 트랜잭션을 수행하는 스마트 컨트랙트 계정 주소                        |
| deployer                      | DATA, 20 Bytes | 배포자 - 계정 팩토리 컨트랙트 주소 (선택 사항)                       |
| deployerData                  | DATA           | 배포자 컨트랙트에 제공되는 데이터 (`deployer`가 설정된 경우)               |
| paymaster                     | DATA, 20 Bytes | 페이마스터 컨트랙트 주소 (선택 사항)                                        |
| paymasterData                 | DATA           | 페이마스터 컨트랙트에 제공되는 데이터 (`paymaster`가 설정된 경우)             |
| executionData                 | DATA           | 실행을 위해 계정 컨트랙트에 제공되는 데이터                         |
| nonceKey                      | QUANTITY       | 192비트 논스 키. `nonceKey != 0` 사용은 RIP-7712에서 정의됩니다.                 |
| nonceSequence                 | QUANTITY       | 64비트 논스 시퀀스. `nonceKey != 0` 사용은 RIP-7712에서 정의됩니다.             |
| builderFee                    | QUANTITY       | sender 또는 paymaster에서 `coinbase`로 전달되는 값                             |
| maxPriorityFeePerGas          | QUANTITY       | 검증자에게 팁으로 포함되는 최대 가스 가격                      |
| maxFeePerGas                  | QUANTITY       | 가스 단위당 최대 수수료                                                     |
| validationGasLimit            | QUANTITY       | 트랜잭션 계정 검증 프레임에 제공되는 가스                           |
| paymasterValidationGasLimit   | QUANTITY       | 트랜잭션 페이마스터 검증 프레임에 제공되는 가스 (`paymaster`가 설정된 경우) |
| paymasterPostOpGasLimit       | QUANTITY       | 트랜잭션 페이마스터 `postOp` 프레임에 제공되는 가스 (`paymaster`가 설정된 경우)   |
| callGasLimit                  | QUANTITY       | 트랜잭션 RIP-7560 실행 콜 프레임에 제공되는 가스                      |
| accessList                    | OBJECT         | EIP-2930 호환 접근 목록 구조                                        |
| authorizationsList            | ARRAY          | EOA에 주입되는 EIP-7702 호환 컨트랙트 목록                         |
| authorizationData             | DATA           | 계정이 트랜잭션 검증에 사용할 데이터                         |

### RIP-7560 트랜잭션 영수증 정의:

트랜잭션 영수증 객체 형태는 RIP-7560 트랜잭션 영수증을 지원하도록 수정됩니다.

| 이름                         | 타입             | 설명                                                                                                                          |
|------------------------------|------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| sender                       | DATA, 20 Bytes   | 이 트랜잭션 발신자 주소                                                                                            |
| paymaster                    | DATA, 20 Bytes   | 트랜잭션 비용을 지불하는 페이마스터 주소, 그렇지 않으면 `null`                                                       |
| deployer                     | DATA, 20 Bytes   | 트랜잭션에 포함된 경우 배포자 주소, 그렇지 않으면 `null`                                                       |
| senderCreationGasUsed        | QUANTITY         | sender 배포 프레임에서 실제 사용된 가스량, 프레임이 실행되지 않으면 0                                        |
| senderValidationGasUsed      | QUANTITY         | sender 검증 프레임에서 실제 사용된 가스량                                                                       |
| paymasterValidationGasUsed   | QUANTITY         | 페이마스터 검증 프레임에서 실제 사용된 가스량, 프레임이 실행되지 않으면 0                                     |
| executionGasUsed             | QUANTITY         | RIP-7560 실행 콜 프레임에서 실제 사용된 가스량                                                                 |
| postOpGasUsed                | QUANTITY         | 페이마스터 `postOp` 프레임에서 실제 사용된 가스량, 프레임이 실행되지 않으면 0                                       |
| executionStatus              | QUANTITY         | 0 (성공), 1 (실행 되돌림), 2 (`postOp` 되돌림), 3 (실행과 `postOp` 모두 되돌림) 실행 프레임 상태   |
| validationLogs               | ARRAY            | 이 트랜잭션의 검증 프레임이 생성한 로그 객체 배열                                                           |
| transactionHash              | DATA, 32 Bytes   | 트랜잭션 해시                                                                                                             |
| transactionIndex             | QUANTITY         | 블록 내 트랜잭션 인덱스 위치 정수                                             |
| blockHash                    | DATA, 32 Bytes   | 이 트랜잭션이 포함된 블록 해시                                                                     |
| blockNumber                  | QUANTITY         | 이 트랜잭션이 포함된 블록 번호                                                                          |
| cumulativeGasUsed            | QUANTITY         | 이 트랜잭션이 블록에서 실행될 때 사용된 총 가스량                                                        |
| effectiveGasPrice            | QUANTITY         | 가스 단위당 지불된 기본 수수료와 팁의 합                                                                                |
| gasUsed                      | QUANTITY         | 이 특정 트랜잭션만이 사용한 가스량                                                           |
| logs                         | ARRAY            | 이 트랜잭션의 실행 프레임이 생성한 로그 객체 배열                                                            |
| logsBloom                    | DATA, 256 Bytes  | 라이트 클라이언트가 관련 로그를 빠르게 검색하기 위한 블룸 필터                                                                     |
| type                         | QUANTITY         | 트랜잭션 타입 정수                                                                                                      |

### 가스 수수료는 컨트랙트 잔액에서 직접 청구됩니다

`AA_TX_TYPE` 트랜잭션의 최대 가스 비용은 다음과 같이 정의됩니다:

```

maxPossibleGasCost = AA_BASE_GAS_COST +
  validationGasLimit +
  paymasterValidationGasLimit +
  callGasLimit +
  paymasterPostOpGasLimit

```

`paymaster`가 지정되지 않으면, 어떤 실행 프레임에서든 계산이 수행되기 전에
`sender` 주소 잔액에서 `maxPossibleGasCost`가 선불로 청구됩니다.
`paymaster`가 지정되면, 가스 비용은 페이마스터 잔액에서 청구됩니다.
선불 청구되는 계정(sender 또는 paymaster)의 잔액이 부족하면
트랜잭션은 무효입니다.
트랜잭션 실행이 완료된 후 선불 청구된 주소는 가스 환불을 받을 수 있습니다.

`maxPriorityFeePerGas`와 `maxFeePerGas`의 의미는 [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)에서
정의된 것과 동일합니다.

### 트랜잭션 입력에 대해 청구되는 가스 수수료

기존의 모든 트랜잭션 타입에서는 `data` 매개변수에 대해 바이트당 G_txdatazero (4 가스)와 G_txdatanonzero (16 가스)가 청구됩니다.

트랜잭션 타입 AA_TX_TYPE은 다음 동적 길이 입력을 도입합니다: `executionData`, `paymasterData`,
`deployerData`, `authorizationData`. 이러한 각 매개변수의 가스 비용은 트랜잭션 데이터 비용에 포함됩니다.
이 트랜잭션 데이터 가스 비용은 `calldataGasUsed`라고 하며, 트랜잭션 실행 전에 `validationGasLimit`에서 차감됩니다.
`validationGasLimit`이 `calldataGasUsed`보다 작으면 트랜잭션은 무효로 간주됩니다.

### 빌더 수수료

블록 빌더가 `AA_TX_TYPE` 트랜잭션을 블록에 포함시키기 위해 수행해야 하는 추가 오프체인 작업과
L2 롤업에서 운영하는 빌더의 잠재적 L1 가스 비용을 고려해야 하며,
이 작업은 검증에 소비되는 가스량과 일치하지 않고 가스 가격과 연결되지 않으므로,
`sender`는 블록 빌더에게 "팁"으로 추가 `builderFee`를 지불할 수 있습니다.

이 값은 wei 단위이며, 가스 선불 청구의 일부로 `sender` 또는 지정된 경우 `paymaster`에서
현재 블록의 `coinbase`로 전달됩니다.

### 단일 트랜잭션에 대한 다중 실행 프레임

모든 기존 트랜잭션 타입은 잔액, 논스, 서명이 확인되는 암묵적 검증 단계와
트랜잭션 ECDSA 서명으로 결정되는 주소인 `tx.origin == msg.sender`인
단일 최상위 실행 프레임만 있습니다.

그러나 `AA_TX_TYPE` 타입의 트랜잭션을 처리할 때는 여러 실행 프레임이 생성됩니다.
가능한 프레임의 전체 목록은 ERC-4337 흐름을 복제하려고 합니다:

1. 검증 단계
   * `sender` 배포 프레임 (계정당 한 번)
   * `sender` 검증 프레임 (필수)
   * `paymaster` 검증 프레임 (선택 사항)
2. 실행 단계
   * `sender` 실행 프레임 (필수)
   * `paymaster` 트랜잭션 후 프레임 (선택 사항)

"검증 단계"의 모든 실행 프레임은 되돌림 없이 성공적으로 완료되어야 하며,
`sender`와 `paymaster` 검증 프레임 모두 해당 `AA_ENTRY_POINT`
승인 콜백 함수 호출을 포함해야
트랜잭션이 블록 내 주어진 위치에 대해 유효한 것으로 간주됩니다.

모든 최상위 프레임에서 전역 변수는 다음과 같은 의미를 갖습니다:

| 옵코드 이름 | Solidity 동등    | 값                                                                         |
|-------------|---------------------|-------------------------------------------------------------------------------|
| `CALLER`    | `msg.sender`        | `AA_ENTRY_POINT` 주소. "배포 프레임"에서는 `AA_SENDER_CREATOR`. |
| `ORIGIN`    | `tx.origin`         | 트랜잭션 `sender` 주소                                              |
| `CALLDATA*` | `msg.data`          | 트랜잭션 데이터는 해당 프레임의 입력으로 설정됨              |

### 트랜잭션 실행 컨텍스트

일부 EVM 동작은 트랜잭션 컨텍스트에 따라 달라집니다. 이러한 동작은:
1. [EIP-2200](../eip-2200)에 따른 SSTORE 옵코드 비용
2. [EIP-2929](../eip-2929)에 따른 콜드 주소 및 슬롯 접근 비용
3. [EIP-1163](../eip-1163)에 따른 임시 스토리지 내에서 사용 가능한 값
4. [EIP-3529](../eip-3529)에 따른 실행 후 할당되는 최대 가스 환불량
5. [EIP-6780](../eip-6780)에 따른 SELFDESTRUCT 옵코드 가용성

이러한 기능은 트랜잭션을 여러 프레임으로 분리해도 영향을 받지 않습니다.
즉, 예를 들어 한 프레임에서 TSTORE로 설정한 값은 다음 프레임에서도 사용 가능합니다.

#### Sender 배포 프레임

`deployer` 주소는 `AA_SENDER_CREATOR` 주소에서 `deployerData`를 콜 데이터 입력으로 호출됩니다.

이 프레임의 가스 한도는 `validationGasLimit`으로 설정됩니다.
이 프레임에서 사용된 가스량은 `senderCreationGasUsed`라고 합니다.

sender 배포 프레임은 반드시 `sender` 주소가 컨트랙트 코드로 초기화되는 결과를 가져야 합니다.

#### Sender 검증 프레임

온체인에서 AA 트랜잭션을 나타내기 위해 다음 Solidity 구조체를 정의합니다:

```solidity

struct TransactionTypeRIP7560 {
    address sender;
    address paymaster;
    address deployer;
    uint256 nonceKey;
    uint256 nonceSequence;
    uint256 builderFee;
    uint256 maxFeePerGas;
    uint256 maxPriorityFeePerGas;
    uint256 validationGasLimit;
    uint256 paymasterValidationGasLimit;
    uint256 paymasterPostOpGasLimit;
    uint256 callGasLimit;
    bytes senderValidationData;
    bytes paymasterData;
    bytes deployerData;
    bytes executionData;
    Authorization[] authorizationsList;
}

struct Authorization {
    uint256 chainId;
    address delegate;
    uint256 nonce;
    uint8 yParity;
    uint256 r;
    uint256 s;
}

```

그런 다음 다음 Solidity 메서드를 정의하고 트랜잭션의 `sender`가 해당 데이터로 호출됩니다:

```solidity

function validateTransaction(uint256 version, bytes32 txHash, bytes transaction) external;

```

이 프레임의 가스 한도는 `validationGasLimit - senderCreationGasUsed - calldataGasUsed`로 설정됩니다.\
`transaction` 매개변수는 `TransactionTypeRIP7560`의 ABI 인코딩으로 해석됩니다.\
`txHash` 매개변수는 빈 `authorizationData`를 가진 AA_TX_TYPE 트랜잭션의 해시를 나타내며,
[트랜잭션 타입 AA_TX_TYPE 해시 계산](#트랜잭션-타입-aa_tx_type-해시-계산) 섹션에서 정의됩니다.\
`version` 매개변수는 이 EIP의 향후 개정에서 이 구조체가 변경될 경우 Solidity 메서드 ID를
유지하기 위해 추가되었습니다.

이 프레임에서 사용된 가스량은 `senderValidationGasUsed`라고 합니다.

그런 다음 `AA_ENTRY_POINT` 승인 콜백 함수로 다음 Solidity 메서드를 정의합니다:

```solidity
function acceptAccount(uint256 validAfter, uint256 validUntil) external;
```

```solidity
function sigFailAccount(uint256 validAfter, uint256 validUntil) external;
```

`AA_ENTRY_POINT` 승인 콜백 호출은 다음과 같은 의미를 갖습니다:

- `acceptAccount` - 이 콜백은 계정이 트랜잭션을 검증하고 실행 비용 지불에 동의한 후 호출됩니다.
- `sigFailAccount` - 이 콜백은 트랜잭션이 구문적으로 유효하지만 `authorizationData`가 올바르지 않을 때 계정에 의해 호출됩니다.\
이 콜백은 가스 추정 중에 사용되며 유효한 트랜잭션을 나타내지 **않습니다**.

콜백 함수에 전달되는 매개변수는 다음과 같은 의미를 갖습니다:

- **validAfter** - 타임스탬프. 트랜잭션은 이 시간 이후에만 유효합니다.
- **validUntil** - 타임스탬프. 트랜잭션은 이 시간까지만 유효합니다. 0은 "무기한 유효"를 의미하는 특별한 값입니다.

계정은 유효한 것으로 간주되려면 `AA_ENTRY_POINT`에 정확히 한 번 호출해야 합니다.
계정이 `AA_ENTRY_POINT` 콜백을 호출하지 않거나,
`acceptAccount` 이외의 호출을 하거나,
`AA_ENTRY_POINT`에 여러 번 호출하거나,
실행이 되돌려지는 등의 다른 결과는 검증 실패로 간주되며,
트랜잭션은 거부되고 온체인에 포함되지 않습니다.

이러한 콜백은 계정에서 직접 호출되거나 계정 컨텍스트에서 실행되는 `DELEGATECALL` 내에서 호출될 수 있습니다.
검증 프레임 중에 다른 컨트랙트의 컨텍스트에서 콜백이 호출되면 트랜잭션은 거부되고 온체인에 포함되지 않습니다.

#### 페이마스터 검증 프레임

트랜잭션의 `paymaster`가 지정된 경우 다음 데이터로 호출됩니다:

```solidity
function validatePaymasterTransaction(uint256 version, bytes32 txHash, bytes transaction) external;
```

이 프레임의 가스 한도는 `paymasterValidationGasLimit`으로 설정됩니다.

이 프레임에서 사용된 가스량은 `paymasterValidationGasUsed`라고 합니다.

- `version` 매개변수는 `VERSION`입니다
- `transaction` 매개변수는 `TransactionTypeRIP7560`의 ABI 인코딩으로 해석됩니다.\
- `txHash` 매개변수는 빈 `authorizationData`를 가진 AA_TX_TYPE 트랜잭션의 해시를 나타내며,
[트랜잭션 타입 AA_TX_TYPE 해시 계산](#트랜잭션-타입-aa_tx_type-해시-계산) 섹션에서 정의됩니다.


그런 다음 `AA_ENTRY_POINT` 승인 콜백 함수로 다음 Solidity 메서드를 정의합니다:

```solidity
function acceptPaymaster(uint256 validAfter, uint256 validUntil, bytes context);
```

```solidity
function sigFailPaymaster(uint256 validAfter, uint256 validUntil, bytes context);
```

`AA_ENTRY_POINT` 승인 콜백 호출은 다음과 같은 의미를 갖습니다:

- `acceptPaymaster` - 이 콜백은 페이마스터가 트랜잭션을 검증하고 실행 비용 지불에 동의한 후 호출됩니다.
- `sigFailPaymaster` - 이 콜백은 `paymasterData`에 일종의 서명이 포함될 것으로 예상되지만 유효한 서명이 포함되지 않은 경우 페이마스터에 의해 호출됩니다.\
이 콜백은 가스 추정 중에 사용되며 유효한 트랜잭션을 나타내지 **않습니다**.

콜백 함수에 전달되는 매개변수는 다음과 같은 의미를 갖습니다:

- `validAfter`, `validUntil` - `acceptAccount`에서 정의된 것과 동일
- `context` - 페이마스터 컨트랙트에서 제공하는 선택적 바이트 배열로, 나중에 `postPaymasterTransaction`에 전달됩니다.
이 값의 길이는 `MAX_CONTEXT_SIZE` 바이트를 초과해서는 안 됩니다.


페이마스터는 유효한 것으로 간주되려면 `AA_ENTRY_POINT`에 정확히 한 번 호출해야 합니다.
페이마스터가 `AA_ENTRY_POINT` 콜백을 호출하지 않거나,
`acceptPaymaster` 이외의 호출을 하거나,
`AA_ENTRY_POINT`에 여러 번 호출하거나,
실행이 되돌려지는 등의 다른 결과는 검증 실패로 간주되며,
트랜잭션은 거부되고 온체인에 포함되지 않습니다.

이러한 콜백은 페이마스터에서 직접 호출되거나 페이마스터 컨텍스트에서 실행되는 `DELEGATECALL` 내에서 호출될 수 있습니다.
검증 프레임 중에 다른 컨트랙트에서 콜백이 호출되면 트랜잭션은 거부되고 온체인에 포함되지 않습니다.

#### Sender 실행 프레임

`sender` 주소가 `executionData` 입력으로 호출됩니다.

이 프레임의 가스 한도는 `callGasLimit`으로 설정됩니다.\
`calldataGasUsed` 값 계산은
[트랜잭션 입력에 대해 청구되는 가스 수수료](#트랜잭션-입력에-대해-청구되는-가스-수수료) 섹션에서 정의됩니다.\
이 프레임에서 사용된 가스량은 `gasUsedByExecution`이라고 합니다.

검증 프레임은 실행 프레임이 되돌려져도 되돌려지지 않습니다.
`postPaymasterTransaction`은 여전히 `success: false` 플래그와 함께 호출될 수 있습니다.

#### 페이마스터 트랜잭션 후 프레임

sender 실행 프레임이 끝난 후 `paymaster`는 일종의 정리 또는 기록 관리와 같은
트랜잭션 후 로직을 수행해야 할 수 있습니다.
가스 지불 검증 프레임이 `acceptPaymaster` 콜백에서 0이 아닌 `context`를 제공한 경우,
`paymaster`는 다음 입력으로 다시 호출됩니다:

```solidity

function postPaymasterTransaction(bool success, uint256 actualGasCost, bytes context) external;

```

- `success`는 이 트랜잭션의 실행 프레임이 되돌림 없이 완료되었는지 여부를 나타냅니다.
- `actualGasCost` 매개변수는 이 시점까지 이 트랜잭션에 대해 페이마스터가 실제로 지출한 가스량입니다. `postPaymasterTransaction` 함수 자체의 가스 비용은 포함되지 않습니다.

이 프레임의 가스 한도는 `paymasterPostOpGasLimit`으로 설정됩니다.

`postPaymasterTransaction` 프레임에서의 되돌림은 트랜잭션의 실행 프레임도 되돌립니다.
`paymaster`에서 청구되는 가스 수수료는 검증 프레임과 되돌려진 실행 프레임 및 postPaymasterTransaction 프레임의 가스 비용을 포함합니다.

### 실행 흐름 다이어그램

계정 추상화 트랜잭션에 의해 결정되는 실행 흐름은 다음 흐름 다이어그램으로 시각화됩니다:

![](../assets/rip-7560/flow_diagram.png)
*네이티브 계정 추상화 트랜잭션의 실행 흐름*

### 실행 계층 트랜잭션 검증

실행 계층에서 블록에 대한 트랜잭션 유효성 조건은 다음과 같이 확장됩니다:

```go

func validateAccountAbstractionTransaction(tx *Transaction) {
    assert !(sender.code.length > 0 && deployer != address(0))

    if (sender.code.length == 0 && deployer != address(0)) {
        calldataGasUsed := calculateCallDataGasUsed(tx)
        retDeployer, error := evm.Call(
            from: AA_SENDER_CREATOR,
            to: deployer,
            input: deployerData,
            gas: validationGasLimit - calldataGasUsed)
        assert error == nil
        assert sender.code.length > 0
    }

    senderInput := ABI.encodeWithSelector('validateTransaction', tx, tx.hash);
    callbackParamsSender, error := evm.Call(
        from: AA_ENTRY_POINT,
        to: sender,
        input: senderInput,
        gas: validationGasLimit - retDeployer.gasUsed)
    assert error == nil
    assert callbackParamsSender != nil
    assert Date.now() <= callbackParamsSender.validUntil
    assert Date.now() >= callbackParamsSender.validAfter
    assert callbackParamsSender.isValidAuthorizationData

    if (paymaster != address(0)) {
        paymasterInput := ABI.encodeWithSelector('validatePaymasterTransaction', tx, tx.hash)
        callbackParamsPaymaster, error := evm.Call(
            from: AA_ENTRY_POINT,
            to: paymaster,
            input: paymasterInput,
            gas: paymasterValidationGasLimit)
        assert error == nil
        assert callbackParamsPaymaster != nil
        assert Date.now() <= callbackParamsPaymaster.validUntil
        assert Date.now() >= callbackParamsPaymaster.validAfter
        assert callbackParamsPaymaster.isValidAuthorizationData
    }
}

```

DoS 공격 벡터로부터 방어하기 위해 블록 빌더는 [ERC-7562](https://eips.ethereum.org/EIPS/eips/eip-7562)에
설명된 옵코드 금지 및 스토리지 접근 규칙을 고려해야 합니다(SHOULD).

[블록 검증](#실행-계층-블록-검증)은 AA 트랜잭션이 없는 경우와 거의 동일한 양의 작업을 수행합니다.
어떤 경우든 검증은 상태 변경을 확인하기 위해 전체 블록을 실행해야 합니다.
이 실행 중에 현재 서명, 논스, 가스 지불을 검증합니다.
계정 추상화에서는 모든 검증 프레임이 성공했는지도 검증합니다.
페이마스터 검증 프레임에서 트랜잭션 후 프레임으로 전달되는 `context` 값을 저장하는 데
주로 사용되는 필요한 메모리가 약간 증가합니다.

모든 트랜잭션 검증 단계가 성공적으로 실행되고 `AA_ENTRY_POINT` 콜백에 올바른 값을 제공하는 한
블록은 유효한 것으로 간주됩니다.
검증 프레임에 적용되는 규칙을 완화하려는 블록 빌더는 그렇게 할 수 있습니다(MAY).

### 트랜잭션 흐름 다이어그램

단일 트랜잭션을 확대하면, AA 트랜잭션의 검증 부분에는 여러 실행 프레임이 포함될 수 있습니다:

![](../assets/rip-7560/zoom_into_transaction.png)
*블록 내 단일 네이티브 계정 추상화 트랜잭션 내의 프레임*

### 트랜잭션 유효 시간 범위 매개변수

`페이마스터 검증 프레임`과 `Sender 검증 프레임` 각각 `validUntil`과 `validAfter` 값을 제공합니다.

이 값들은 `sender`와 `paymaster` 컨트랙트가 트랜잭션이 유효할 블록의 시간 범위를 지정할 수 있게 합니다.

트랜잭션은 이 시간 범위 외의 블록에 포함될 수 없습니다.
포함된 경우 해당 블록은 무효로 간주됩니다.

`validUntil = 0`과 `validAfter = 0`을 전달하면 검사가 비활성화됩니다.

### 트랜잭션 타입 AA_TX_TYPE 해시 계산

```

keccak256(AA_TX_TYPE || rlp(transaction_payload)

```

`chainId`와 `accessList` 매개변수는 트랜잭션 해시 계산에 포함되지만
`TransactionTypeRIP7560` 구조체의 일부로 온체인에서 사용할 수 없습니다.

트랜잭션 서명 중 사용될 트랜잭션 해시와 `sender`에 의한 트랜잭션 서명 검증을 계산하기 위해,
`authorizationData` 매개변수의 값은 빈 바이트 배열로 간주됩니다.

## 근거

### 코어 EIP에서 Solidity 메서드 선택자 사용

이 계정 추상화 제안에서 `sender` 또는 `paymaster`와 같은 역할을 하는 컨트랙트는
트랜잭션을 검증하기 위해 어떤 코드를 실행할지 알아야 하고 제공된 calldata를 이해해야 합니다.

가장 간단한 구현은 확립된 사실상의 표준인 Solidity 4바이트 메서드 선택자에 의존하는 것이라고 주장합니다.

### `AA_SENDER_CREATOR` 주소에서 `deployer` 호출

`deployer`가 `AA_ENTRY_POINT`에서 호출되지 않고 `AA_SENDER_CREATOR`에서 호출되는 것이 중요합니다.

이는 `AA_ENTRY_POINT`가 성공적인 검증을 먼저 완료하지 않고는 `sender` 실행 함수에 대한
호출을 절대로 시작할 수 없음을 보장하는 데 필요합니다.
이 보호 없이는 `deployerData` 필드를 제어하지 않으므로,
`AA_ENTRY_POINT`에서 `sender`로의 정당한 호출처럼 보이도록 구성될 수 있습니다.

### `AA_ENTRY_POINT` 승인 콜백 사용

스마트 컨트랙트 컨텍스트에서 성공적인 검증 프레임 실행은 트랜잭션 가스 지불로 이어집니다.
모든 의심 없는 컨트랙트가 RIP-7560 트랜잭션 검증을 "수락"하도록 속아 넘어가는 것을 방지하는 것이 중요하며,
이는 해당 컨트랙트가 고갈될 수 있습니다.

이를 위해 RIP-7560 트랜잭션 수락을 나타내기 위해 `AA_ENTRY_POINT` 주소에 대한 특정 호출이 필요합니다.

### `authorizationData` 검사 실패에 대한 `sigFailAccount` 및 `sigFailPaymaster` 사용

이 콜백은 해당 검증 프레임 중에 트랜잭션 `authorizationData`를 제외한 모든 관련 세부 사항을
확인할 수 있는 경우 계정 또는 페이마스터에 의해 호출됩니다.

이 콜백은 가스 추정 중에 사용되며, 지갑과 앱이 실제 서명을 생성하기 전에
검증 프로세스에서 사용되는 가스를 결정하는 데 도움이 됩니다.\
유효한 `authorizationData`로 업데이트될 때 트랜잭션이 동일한 양의 가스를 소비할 것으로 예상됩니다.

## 하위 호환성

이 EIP는 ERC-4337에서 확립된 대부분의 설계 요소를 유지합니다. 이를 통해 동일한 클라이언트 코드와 스마트
컨트랙트를 최소한의 수정 또는 수정 없이 두 시스템에서 사용할 수 있으면서 상당한 UX 개선을 제공합니다.

기존 컨트랙트는 변경의 영향을 크게 받지 않습니다.
`tx.origin`이 EOA임이 보장된다는 가정은 더 이상 유효하지 않습니다.
`tx.origin`이 현재 트랜잭션 비용을 지불하는 주소라는 가정도 더 이상 유효하지 않습니다.

이더리움 트랜잭션에 대해 단일 최상위 실행 프레임을 기대하는 모든 코드는
새로운 트랜잭션 타입을 수용해야 합니다.

[EIP-3607](https://eips.ethereum.org/EIPS/eip-3607)은 배포된 코드가 있는 sender의 트랜잭션 금지를 도입합니다.
이 제한은 AA_TX_TYPE 트랜잭션에는 적용되지 않습니다.

### 기존 ERC-4337 프로젝트의 마이그레이션 경로 및 향후 로드맵

#### 기존 번들러는 네트워크에서 공존할 수 있음

ERC-4337은 프로토콜 변경이 아니며 이 EIP와 무기한 병렬로 운영될 수 있습니다.
ERC-4337과의 유사성을 감안할 때, 동일한 블록 빌더가 ERC-4337과 `AA_TX_TYPE` 트랜잭션을 쉽게 지원할 수 있습니다.

#### 계정은 `EntryPoint`를 어댑터 컨트랙트로 업그레이드해야 함

ERC-4337 팀은 `paymaster`와 `sender` 컨트랙트의 ABI를 변환하는 컨트랙트의
참조 구현을 제공할 것입니다. 이 어댑터는 ERC-4337 컨트랙트에 의해
신뢰할 수 있는 `EntryPoint` 주소로 설정될 수 있습니다.

#### 호환성 계층으로 ERC-4337 RPC 호출 지원

`sender` 컨트랙트는 이 EIP가 일부 체인에서 채택되고 다른 체인에서는 채택되지 않을 수 있는 한
전환 기간 동안 ERC-4337과 `AA_TX_TYPE` 트랜잭션을 모두 지원할 수 있습니다(MAY).

## 보안 고려사항

이 EIP는 복잡하고 정교한 메커니즘을 생성하며 스마트 컨트랙트 계정의 사용을 확장하는 것을 목표로 합니다.
이 모든 것이 많은 새로운 위험 벡터와 공격 표면을 생성합니다.

다음은 네이티브 계정 추상화에 관한 알려진 보안 고려사항의 비완전한 목록입니다.

### 컨트랙트 잔액 직접 청구

이 EIP는 스마트 컨트랙트가 `validateTransaction`, `validatePaymasterTransaction`에 해당하는
메서드 ID를 가진 함수에서 `AA_ENTRY_POINT` 주소에 유효한 콜백 호출을 함으로써
단순히 잔액이 청구되는 새로운 방법을 추가합니다.

이는 우연히 또는 악의적으로 이러한 메서드를 포함하지만 `AA_TX_TYPE` 트랜잭션에서
`sender` 또는 `paymaster`로 사용될 수 있다는 사실에 대해 공개하지 않는
컨트랙트에 대한 새로운 종류의 위험을 생성합니다.

이 우려는 이러한 컨트랙트가 `AA_ENTRY_POINT` 주소에서 `acceptAccount` 또는 `acceptPaymaster` 콜백을
호출하도록 요구함으로써 완화되며, 이는 컨트랙트의 `AA_ENTRY_POINT` 주소와의 상호작용을 명시적으로 만듭니다.
코드 검토자는 RIP-7560 트랜잭션의 이 기능을 인식해야 합니다.

### 검증 프레임에서 되돌림 이유 관찰

기존 트랜잭션 타입은 되돌려지더라도 블록에 포함되며 디버깅 목적으로 되돌림 이유를 제공합니다.
트랜잭션이 온체인에 포함되지 않을 수 있는 원인의 매우 짧은 목록이 있습니다:

* 낮은 가스 수수료
* 불충분한 잔액
* 유효하지 않은 논스
* 검열

이는 `AA_TX_TYPE` 트랜잭션의 검증 단계에서 발생하는 되돌림의 경우에는 해당되지 않습니다.
이를 해결하기 위해 개발자는 서명되는 이러한 트랜잭션의 유효성을 추적해야 하며,
의도한 시간 내에 포함되지 않은 트랜잭션이 사용자가 보낸 것에 대해
예기치 않게 다시 유효해지지 않도록 `validUntil` 시간 범위 매개변수에 의존하는 것이 권장됩니다.

### 블록 빌더에 대한 서비스 거부 공격

블록 빌더가 할당된 시간 내에 트랜잭션으로 블록을 채울 수 있는 능력을 고려하는 것이 중요합니다.

블록 유효성 측면에서, 모든 검증 및 RIP-7560 실행 콜 프레임은 블록에 포함될 때 모든 상태를 읽고 쓸 수 있습니다.
이는 트랜잭션이 기술적으로 서로를 무효화할 수 있음을 의미합니다.

블록 빌더는 블록에 포함시킨 후 단일 트랜잭션에 의해 여러 적격 트랜잭션이 무효화될 위험에 직면할 수 있으며,
이는 서비스 거부를 유발합니다.
시퀀서와 같은 블록 빌더는 들어오는 트랜잭션을 수신 순서대로 처리하는 한 이러한 위험이 없습니다.

완화의 일환으로, AA 트랜잭션은 블록 빌더에 대한 DoS를 피하기 위해 스토리지 접근 규칙에 의해
제한되어야 합니다(SHOULD).
이러한 규칙은 [ERC-7562](https://eips.ethereum.org/EIPS/eips/eip-7562)에서 정의됩니다.

완전한 완화는 [RIP-7711](./rip-7711.md)에 설명된 대로 검증을 별도의 컨텍스트로 분리함으로써 달성될 수 있습니다.

### 원자적 "검증 및 실행" 폴백 함수

스마트 컨트랙트 계정 개발자는 어떤 이유로든 `AA_TX_TYPE` 트랜잭션을 사용할 수 없게 되는 경우에도
사용자가 계정을 제어할 수 있도록 하는 것이 좋습니다.

이는 스마트 컨트랙트 계정의 검증 및 실행 핸들러 모두에 대한 호출을 포함하는
공개 함수를 제공함으로써 쉽게 달성할 수 있습니다.

## 저작권

저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기되었습니다.
